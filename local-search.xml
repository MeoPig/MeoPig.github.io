<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端面试-场景题</title>
    <link href="/2025/09/14/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E5%9C%BA%E6%99%AF%E9%A2%98/"/>
    <url>/2025/09/14/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E5%9C%BA%E6%99%AF%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Vue怎么实现权限管理？"><a href="#1-Vue怎么实现权限管理？" class="headerlink" title="1. Vue怎么实现权限管理？"></a>1. Vue怎么实现权限管理？</h2><h3 id="路由权限"><a href="#路由权限" class="headerlink" title="路由权限"></a>路由权限</h3><p><strong>方案一</strong>：初始化即加载全部路由，并且在路由上添加上相应权限信息，每次路由跳转前做校验。</p><ul><li>缺点：<ul><li>加载所有路由，如果路由很多，而用户不是所有的权限，那么就会造成不必要的加载。</li><li>全局路由守卫里，每次路由跳转都要进行权限判断。</li><li>菜单信息写死在前端里，要改个权限信息，需要重新编译，适合角色固定的情况，</li><li>菜单和路由耦合在一起，定义路由的时候还要添加菜单显示标题，而且路由不一定作为菜单，还要多加字段进行标识。</li></ul></li></ul><p><strong>方案二</strong>：初始化时先挂载不需要权限控制的路由，比如登录页404等。如果用户通过URL强制访问，则会直接进入404，相当于从源头控制。<br>登陆后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用addRoutes添加路由。</p><ul><li>缺点：<ul><li>全局路由守卫里，每次路由跳转都要进行权限判断。</li><li>菜单信息写死在前端里，要改个权限信息，需要重新编译，适合角色固定的情况，</li><li>菜单和路由耦合在一起，定义路由的时候还要添加菜单显示标题，而且路由不一定作为菜单，还要多加字段进行标识。</li></ul></li></ul><h3 id="菜单权限"><a href="#菜单权限" class="headerlink" title="菜单权限"></a>菜单权限</h3><p><strong>方案一</strong>：菜单与路由分离，菜单由后端返回，前端定义路由信息。</p><ul><li><p>每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是一一对应的，而后端返回的菜单就已经是经过权限过滤的。</p></li><li><p>如果根据路由name找不到对应的菜单，就表示用户有没权限访问。</p></li><li><p>如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过addRoutes动态挂载。</p></li><li><p><strong>缺点</strong>：</p><ul><li>菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用。</li><li>全局路由守卫里，每次路由跳转都要做判断。</li></ul></li></ul><p><strong>方案二</strong>：菜单和路由都由后端返回</p><p>前端统一定义路由组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Home</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;../pages/Home.vue&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">UserInfo</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;../pages/UserInfo.vue&quot;</span>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">home</span>: <span class="hljs-title class_">Home</span>,<br>    <span class="hljs-attr">userInfo</span>: <span class="hljs-title class_">UserInfo</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>后端路由组件返回以下格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<br>    &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;home&quot;</span>,<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-string">&quot;home&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;home&quot;</span>,<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/userinfo&quot;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-string">&quot;userInfo&quot;</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure><ul><li><p>在将后端返回路由通过addRoutes动态挂载之间，需要将数据处理一下，将component字段换为真正的组件</p></li><li><p>如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理</p></li><li><p><strong>缺点</strong>：</p><ul><li>前后端配合要求高</li><li>全局路由守卫里，每次路由跳转都要做判断。</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端面试-VUE篇</title>
    <link href="/2025/09/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-VUE%E7%AF%87/"/>
    <url>/2025/09/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-VUE%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="1-虚拟dom渲染到页面上时，框架做了什么？"><a href="#1-虚拟dom渲染到页面上时，框架做了什么？" class="headerlink" title="1.虚拟dom渲染到页面上时，框架做了什么？"></a>1.虚拟dom渲染到页面上时，框架做了什么？</h2><p>虚拟DOM（Virtual DOM）是一种编程概念和内存中的数据结构，它使用JavaScript对象来表示和模拟真实DOM树的结构和状态。<br>创建虚拟 DOM 目的就是为了更好将虚拟的节点渲染到页面视图中，虚拟 DOM 对象的节点与真实 DOM 的属性一一照应</p><p>虚拟DOM 渲染到页面时，前端框架会先创建或更新虚拟DOM 树，然后利用 Diff 算法 找出新旧虚拟DOM 树的差异，最后根据差异生成最小的真实DOM 操作指令，批量执行这些操作，并处理事件绑定和生命周期钩子，以高效更新页面并保持与数据的同步。<br>核心处理流程如下：</p><ol><li>虚拟DOM 创建&#x2F;更新：<br>当应用数据发生变化时，框架会生成一个新的虚拟DOM 树。</li><li>差异比较(Diff)：<br>框架使用Diff 算法比较新的虚拟DOM 树和上一次渲染的虚拟DOM 树，找出两者的不同之处。</li><li>生成真实DOM 操作：<br>根据比较结果，框架会生成最小化的真实DOM 操作指令，例如创建新节点、更新属性、删除节点等。</li><li>批量执行DOM 操作：<br>框架会将这些DOM 操作批量地应用到真实的DOM 上，以减少对真实DOM 的直接改动，从而提高性能。</li><li>事件处理：<br>框架会为新生成的或更新的DOM 节点绑定事件监听器，以便响应用户的交互行为。</li><li>生命周期钩子触发：<br>在DOM 更新的过程中，框架还会根据组件的生命周期触发相应的钩子函数，为开发者提供扩展和定制的能力。</li></ol><h2 id="2-Vue有了数据响应式，为什么还需要diff算法？"><a href="#2-Vue有了数据响应式，为什么还需要diff算法？" class="headerlink" title="2. Vue有了数据响应式，为什么还需要diff算法？"></a>2. Vue有了数据响应式，为什么还需要diff算法？</h2><p><strong>数据响应式</strong><br>Vue的数据响应式系统通过Object.defineProperty()（Vue2） 或者ES6的Proxy （Vue3）来实现，主要解决以下问题：</p><ol><li>数据绑定：保证视图与数据的同步更新，当数据发生变化时，视图会自动更新，避免手动操作DOM。</li><li>依赖追踪：Vue能够追踪每个数据的依赖关系，即哪些组件或者计算属性依赖于某个数据。当数据变化时，自动更新依赖的组件或者计算属性。</li></ol><p><strong>虚拟DOM和Diff算法</strong><br>虚拟DOM是一种内存中的表示结构，它是对真实DOM的抽象。Diff算法是一种高效的更新DOM的策略，它通过比较新旧虚拟DOM树的差异，最小化更新操作，提高页面的渲染效率。</p><p><strong>为什么需要Diff算法？</strong></p><ol><li>性能优化：直接操作真实DOM是非常昂贵的，而虚拟DOM可以在内存中快速比较和计算差异。Diff算法帮助减少更新操作的次数和返回，从而提高页面的渲染效率。</li><li>批量更新：Diff算法能够将多次DOM更新操作合并为一次，避免频繁的DOM操作，减少了浏览器的重排和重绘。</li><li>跨平台兼容：虚拟DOM和Diff算法使得Vue可以在不同的平台（如浏览器、小程序、Node.js）上运行，并保持一致的渲染结果。</li><li>更新效率：虽然响应式系统可以自动更更新视图，但是如果每次数据变化都直接操作真实DMO，可能会带来性能问题。Diff算法可以智能的比较新旧DOM树的变化，只更新必要部分，从而提高了更新效率。</li></ol><p><strong>综合作用</strong></p><ol><li>数据响应式：保证了数据和视图的同步更新，提供了便捷的开发方式。</li><li>虚拟DOM+Diff算法：提高页面渲染的效率和性能，减少了不必要的DOM操作，确保了页面的流畅性和响应性。</li></ol><h2 id="3-Vue2和Vue3的差异"><a href="#3-Vue2和Vue3的差异" class="headerlink" title="3. Vue2和Vue3的差异"></a>3. Vue2和Vue3的差异</h2><ul><li><p>源码层面</p><table><thead><tr><th>版本</th><th>区别</th></tr></thead><tbody><tr><td>vue2</td><td>javascript 使用flow进行类型检测</td></tr><tr><td>vue3</td><td>源码使用typescript进行重构，vue对typescript支持更加友好了</td></tr></tbody></table></li><li><p>性能层面</p><table><thead><tr><th>版本</th><th>区别</th></tr></thead><tbody><tr><td>vue2</td><td>使用object.defineProperty来劫持数据的setter和getter方法，对象改变需要借助api去深度监听</td></tr><tr><td>vue3</td><td>使用Proxy来实现数据劫持，删除了一些api($on,$once,$off) fiter等，优化了Block tree,solt,diff 算法等</td></tr></tbody></table></li><li><p>api方面</p><table><thead><tr><th>版本</th><th>区别</th></tr></thead><tbody><tr><td>vue2</td><td>OptionsAPI 在options里写data,methods,created等描述组件对象，多个逻辑可能在不不同地方，代码内聚性低</td></tr><tr><td>vue3</td><td>CompositionAPI 将模块相关代码统一放在一个地方处理，不需要在多个options里查找</td></tr></tbody></table></li><li><p>hook函数增加代码复用性</p><ul><li>vue2使用mixins进行代码逻辑共享，mixins也是由一大堆options组成，如果有多个mixins则可能造成命名冲突等问题。</li><li>vue3可以通过hook函数 将一部分独立的逻辑抽离出去，并且也是响应式的</li></ul></li><li><p>代码写法方面</p><ul><li>vue3支持在template中写多个根，vue2只能有一个</li><li>当内部有异步函数，需要使用到await的时候，可以直接使用，不需要在setup前面加async</li></ul></li><li><p>生命周期</p><table><thead><tr><th>vue2</th><th>vue3</th><th>生命周期</th></tr></thead><tbody><tr><td>beforeCreate()</td><td>setup()</td><td>组件开始创建数据实例之前</td></tr><tr><td>created()</td><td>setup()</td><td>组件数据创建数据实例完成</td></tr><tr><td>beforeMount()</td><td>onBeforeMount()</td><td>DOM挂载之前</td></tr><tr><td>mounted()</td><td>onMounted()</td><td>DOM挂载完成（页面完成渲染）</td></tr><tr><td>beforeUpdate()</td><td>onBeforeUpdate()</td><td>组件数据更新之前</td></tr><tr><td>updated()</td><td>onUpdated()</td><td>组件数据更新之后</td></tr><tr><td>beforeDestroy()</td><td>onBeforeUnmount()</td><td>组件销毁之前</td></tr><tr><td>destroyed()</td><td>onUnmounted()</td><td>组件销毁之后</td></tr></tbody></table></li></ul><h2 id="4-在Vue中父组件怎么监听到子组件的生命周期？"><a href="#4-在Vue中父组件怎么监听到子组件的生命周期？" class="headerlink" title="4.在Vue中父组件怎么监听到子组件的生命周期？"></a>4.在Vue中父组件怎么监听到子组件的生命周期？</h2><ol><li><p>通过事件通信：子组件在生命周期钩子中触发自定义事件，父组件监听该事件，并执行相应的逻辑。</p></li><li><p>使用ref:父组件访问子组件的实例，并在父组件的生命周期钩子中调用子组件的方法。</p></li><li><p>在vue2中有使用 @hook 修饰符（主要用于Vue 2.6+）,vue3没有</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> @<span class="hljs-attr">hook:mounted</span>=<span class="hljs-string">&quot;handleChildMountedHook&quot;</span> /&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">handleChildMountedHook</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;父组件通过 @hook:mounted 监听到子组件挂载&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ol><h2 id="5-Vue响应式原理？"><a href="#5-Vue响应式原理？" class="headerlink" title="5. Vue响应式原理？"></a>5. Vue响应式原理？</h2><p><a href="https://juejin.cn/post/7516369217768898600">参考链接</a></p><ol><li><p>何为响应式：<br>所谓数据响应式就是建立响应式数据与依赖（调用了响应式数据的操作）之间的关系，当响应式数据发生变化时，可以通知那些使用了这些响应式数据的依赖操作进行相关更新操作，可以是DOM更新，也可以是执行一些回调函数。</p></li><li><p>vue2和vue3区别：</p><ul><li>Vue2响应式：利用 Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。也就是对属性的读取、修改进行拦截（数据劫持）。</li><li>Vue3响应式：Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。也就是拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等。直接监听对象而非属性。</li></ul></li><li><p>为什么Vue3不延续Vue2的方案？</p><ul><li>在 Vue2 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的，</li><li>defineProperty定义对象不能监听添加额外属性或修改额外添加的属性的变化；</li><li>defineProperty定义对象不能监听根据自身数组下标修改数组元素的变化。</li><li>Proxy 返回的是一个新对象，而 Object.defineProperty 只能遍历对象属性直接修改。</li></ul></li><li><p>vue3响应式手写</p><ul><li>reactive<br><img src="/2025/09/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-VUE%E7%AF%87/5-1.png" alt=" "></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> reactive =  &lt;T <span class="hljs-keyword">extends</span> object&gt;<span class="hljs-function">(<span class="hljs-params">target: T</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 限制reactive只能传递引用类型，如果传递的不是引用类型，则出警告并将原始值直接返回</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span> || target === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;Reactive can only be applied to objects&#x27;</span>);<br>        <span class="hljs-keyword">return</span> target<br>    &#125;<br><br>    <span class="hljs-comment">// 返回原始值的代理对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;<br>        <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>            <span class="hljs-keyword">const</span> value = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);<br>            <span class="hljs-comment">// 这里需要收集依赖（后面实现）</span><br>            <span class="hljs-title function_">track</span>(target, key);<br>            <span class="hljs-comment">// 如果值是对象，则递归调用reactive</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; value !== <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_">reactive</span>(value); <br>            &#125;<br><br>            <span class="hljs-keyword">return</span> value;<br>        &#125;,<br>        <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver);<br><br>            <span class="hljs-comment">// 这里需要触发更新（后面实现）</span><br>            <span class="hljs-title function_">trigger</span>(target, key)<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;,<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> reactive;<br></code></pre></td></tr></table></figure><ul><li>track（依赖收集），该方法的主要作用就是收集依赖，这里可以使用Map去进行存储依赖关系，Map的key就是我们的代理对象，而value还是一个嵌套的map，存储代理对象的每个key以及对应的依赖函数数组，因为每个key都可以有多个依赖。<br><img src="/2025/09/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-VUE%E7%AF%87/5-2.png" alt=" "></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">track</span> = (<span class="hljs-params">target: object, key: PropertyKey</span>) =&gt; &#123;<br><br>    <span class="hljs-comment">// 先找到target对应的依赖</span><br>    <span class="hljs-keyword">let</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target)<br><br>    <span class="hljs-keyword">if</span>(!depsMap) &#123;<br>        <span class="hljs-comment">// 如果没找到，则说明是第一次收集，需要初始化</span><br>        depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>        targetMap.<span class="hljs-title function_">set</span>(target, depsMap)<br>    &#125;<br>    <span class="hljs-comment">// 接着需要对代理对象的属性进行依赖收集</span><br>    <span class="hljs-keyword">let</span> deps = depsMap.<span class="hljs-title function_">get</span>(key)<br>    <span class="hljs-keyword">if</span>(!deps) &#123;<br>        deps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!deps.<span class="hljs-title function_">has</span>(activeEffect) &amp;&amp; activeEffect) &#123; <br>        <span class="hljs-comment">// 防止重复注册 </span><br>        deps.<span class="hljs-title function_">add</span>(activeEffect) <br><br>    &#125;<br>    depsMap.<span class="hljs-title function_">set</span>(key, deps)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Tracking <span class="hljs-subst">$&#123;<span class="hljs-built_in">String</span>(key)&#125;</span> on`</span>, target);<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>trigger（更新触发），该方法的主要作用就是从 targetMap 中，根据 target 和 key 找到对应的依赖函数集合 deps，然后遍历 deps 执行依赖函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">trigger</span> = (<span class="hljs-params">target: object, key: PropertyKey</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 先找到target对应的依赖map</span><br>    <span class="hljs-comment">// console.log(&#x27;----&#x27;,targetMap)</span><br>    <span class="hljs-keyword">const</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target)<br>    <span class="hljs-keyword">if</span>(!depsMap) <span class="hljs-keyword">return</span><br>    <span class="hljs-comment">// 再找到对应属性的依赖</span><br>    <span class="hljs-keyword">const</span> deps = depsMap.<span class="hljs-title function_">get</span>(key)<br>    <span class="hljs-comment">// 如果没有依赖可执行，则返回</span><br>    <span class="hljs-keyword">if</span>(!deps) <span class="hljs-keyword">return</span><br>    <span class="hljs-comment">// 最后遍历整个依赖set分别执行</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;--deps&#x27;</span>, deps)<br>    deps.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> &#123;<br>        effect?.()<br>    &#125;)<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>effect（副作用管理）），该副作用函数主要是在依赖更新的时候调用，它接受一个函数，在被调用的时候执行这个函数.在 effectFn 函数内部，把函数赋值给全局变量 activeEffect；然后执行 fn() 的时候，就会触发响应式对象的 get 函数，get 函数内部就会把 activeEffect 存储到依赖地图中，完成依赖的收集</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> activeEffect<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">effect</span> = (<span class="hljs-params">fn: () =&gt; <span class="hljs-keyword">void</span></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">effectFn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        activeEffect = effectFn<br>        <span class="hljs-title function_">fn</span>()<br>    &#125;<br><br>    <span class="hljs-title function_">effectFn</span>()<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h2 id="6-Vue中，created和mounted两个钩子之间调用时间差值受什么影响？"><a href="#6-Vue中，created和mounted两个钩子之间调用时间差值受什么影响？" class="headerlink" title="6. Vue中，created和mounted两个钩子之间调用时间差值受什么影响？"></a>6. Vue中，created和mounted两个钩子之间调用时间差值受什么影响？</h2><p>created 和 mounted 这两个生命周期钩子，分别在实例创建和挂载的不同阶段被调用。<br>它们之间的时间差值主要受以下几个因素的影响：</p><ol><li><p>模板编译时间：</p><ul><li>当实例被创建时，Vue 会编译模板（或将模板转换为渲染函数），这个过程在 created 钩子之前完成。如果模板非常复杂或包含大量指令、组件，这个过程会更耗时，从而延长 created 和 mounted 之间的时间差。</li></ul></li><li><p>虚拟 DOM 渲染时间：</p><ul><li>在 mounted 钩子调用之前，Vue 会将虚拟 DOM 渲染为实际的 DOM 元素。渲染复杂的组件树或处理大量数据绑定会增加这段时间。</li></ul></li><li><p>异步操作：</p><ul><li>如果在 created 钩子中发起了异步操作（如 API 请求），这些操作本身不会直接影响 created 和 mounted 的时间差，但如果这些操作涉及数据更新，可能会间接增加挂载时间。</li></ul></li><li><p>浏览器性能：</p><ul><li>浏览器的性能和设备的硬件配置也会影响模板编译和 DOM 渲染的速度，从而影响这两个钩子之间的时间差。</li></ul></li><li><p>其他钩子执行时间：</p><ul><li>在 beforeCreate、created、beforeMount 等钩子中执行的代码也会影响到 mounted 钩子的触发时间。如果这些钩子中有大量计算或耗时操作，也会增加时间差。</li></ul></li></ol><h2 id="7-Vue中推荐在哪个生命周期发起请求？"><a href="#7-Vue中推荐在哪个生命周期发起请求？" class="headerlink" title="7. Vue中推荐在哪个生命周期发起请求？"></a>7. Vue中推荐在哪个生命周期发起请求？</h2><p>在 Vue 中，推荐在 mounted 生命周期发起请求。 mounted 生命周期是在组件挂载完成后调用的，此时 DOM 已经渲染完成，因此可以确保请求数据时，DOM 已经存在，不会出现数据请求失败或者数据请求晚于 DOM 的情况。<br>特定场景：</p><ul><li>SSR（服务器端渲染）:在服务器端渲染中，Vue实例的mounted钩子不会被调用，因为DOM并不会被真正挂载，这种情况需要在created钩子中发起请求。</li><li>依赖数据初始化：如果组件在挂载之前就需要某些数据来初始化，可以在created钩子中发起请求，以确保数据在组件挂载时已经可用。</li></ul><h2 id="8-Vue渲染流程？"><a href="#8-Vue渲染流程？" class="headerlink" title="8. Vue渲染流程？"></a>8. Vue渲染流程？</h2><p>Vue的渲染流程大致分为解析编译、挂载渲染、更新渲染三个阶段。</p><ol><li>解析编译：<br>Vue将模板（或组件的render函数）编译成一个渲染函数，该函数用于生成虚拟DOM树。</li><li>挂载渲染：<br>运行时渲染器调用渲染函数，生成虚拟DOM树。然后，它会遍历虚拟DOM树，创建真实的DOM节点并将其插入到页面中，完成首次渲染。</li><li>更新渲染：<br>当组件的数据发生变化时，Vue会重新执行渲染函数，生成新的虚拟DOM树。渲染器随后会比较新旧两棵虚拟DOM树的差异，并只将需要更改的部分应用到真实DOM上。</li></ol><p>详细步骤：</p><ul><li>初始化：<br>用户在main.js中通过<code>new Vue()或createApp()</code>创建Vue实例。</li><li>编译模板：<br>Vue通过解析模板生成抽象语法树（AST），再根据AST生成渲染函数。</li><li>挂载（初次渲染）：<ul><li>渲染函数被执行，生成虚拟DOM（Virtual DOM，简称VNode）树。</li><li>渲染器调用<code>patch()</code>方法，根据虚拟DOM创建真实的DOM节点。</li><li>真实DOM树最终被插入到页面中的指定挂载点（如<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>）。</li></ul></li><li>更新：<ul><li>当响应式数据发生变化时，相关的组件会被重新渲染。</li><li>渲染函数再次执行，生成新的虚拟DOM树。</li><li><code>patch()</code>方法会对比新旧虚拟DOM树的差异（使用Diff算法）。</li><li>只有差异部分会被更新到真实DOM上，避免不必要的重绘和重排，从而提高性能。</li></ul></li></ul><p>核心概念：</p><ul><li>虚拟DOM (Virtual DOM)：:Vue使用虚拟DOM作为真实DOM的中间层，将DOM操作抽象为JavaScript对象。</li><li>Diff算法：:用于比较新旧两棵虚拟DOM树，找出需要更新的节点。</li><li>渲染器：:负责调用渲染函数、生成虚拟DOM，并根据虚拟DOM操作真实DOM。</li></ul><h2 id="8-vue中computed和watch的区别？"><a href="#8-vue中computed和watch的区别？" class="headerlink" title="8. vue中computed和watch的区别？"></a>8. vue中computed和watch的区别？</h2><ul><li>computed 是计算属性，有缓存功能。它的底层会通过 dirty 变量来判断是否重新计算。只有在依赖数据发生变化时才会重新计算，性能会更好。</li><li>而 watch 没缓存，但 watch 能执行异步和比较复杂的逻辑操作。</li><li>computed 适用于多对一，也就是这个缓存属性受多个属性影响，例如购物车商品结算；</li><li>而 watch 适用于一对多，也就是监听的属性影响多个属性，例如搜索框搜索。</li></ul><h2 id="9-组合式API与选项式API区别？"><a href="#9-组合式API与选项式API区别？" class="headerlink" title="9. 组合式API与选项式API区别？"></a>9. 组合式API与选项式API区别？</h2><ul><li>在逻辑组织和逻辑复用方面，组合式优于选项式。</li><li>组合式API几乎是函数，会有更好的类型推断。</li><li>组合式API 对tree-shaking友好，代码也更容易压缩</li><li>组合式API中见不到this的使用，减少了this指向不明的情况</li></ul><h2 id="10-vue3相比于vue2的性能提升体现在哪里？"><a href="#10-vue3相比于vue2的性能提升体现在哪里？" class="headerlink" title="10. vue3相比于vue2的性能提升体现在哪里？"></a>10. vue3相比于vue2的性能提升体现在哪里？</h2><ol><li><strong>编译阶段</strong><ul><li><strong>diff算法优化</strong>：vue3在diff算法中相比vue2添加了静态标记，为会发生变化的地方添加了一个flag，下次发生变化的时候直接找该地方进行比较。</li><li><strong>静态提升</strong>：vue中对不参与更新的元素会做静态提升，只会被创建一次，在有其他变化导致的重新渲染时直接复用。</li><li><strong>事件监听缓存</strong>：默认情况下绑定事件行为会被视为动态绑定，所以每次都会追踪它的变化。</li><li><strong>SSR优化</strong>：当静态内容达到一定量级，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml,就不需要创建对象，然后根据对象渲染。</li></ul></li><li><strong>源码体积</strong><br>vue3移除了不常用API，并引入tree shanking,任何一个函数仅仅只在其被用到的时才打包。</li><li><strong>响应式系统</strong><br>  vue2采用object.defineProperty,来劫持对象，然后深度遍历所有属性。而vue3采用proxy，可以对整个对象监听，不需要深度遍历<ul><li>可以监听动态属性的添加</li><li>可以监听到数组的索引和数组length属性</li><li>可以监听删除属性</li></ul></li></ol><h2 id="11-说说对vue中keep-alive的理解"><a href="#11-说说对vue中keep-alive的理解" class="headerlink" title="11. 说说对vue中keep-alive的理解"></a>11. 说说对vue中keep-alive的理解</h2><ol><li><p>含义：keep-alive是vue内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们。</p><ul><li><p>keep-alive组件的属性有：</p><ul><li>include：指定需要缓存的组件名称</li><li>exclude：指定不需要缓存的组件名称</li><li>ax：指定缓存组件的最大数量</li></ul></li><li><p>设置keep-alive的组件会多出两个生命周期钩子（onActivated与onDeactivated）</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; onActivated, onDeactivated &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-title function_">onActivated</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 调用时机为首次挂载</span><br>  <span class="hljs-comment">// 以及每次从缓存中被重新插入时</span><br>&#125;)<br><br><span class="hljs-title function_">onDeactivated</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在从 DOM 上移除、进入缓存</span><br>  <span class="hljs-comment">// 以及组件卸载时调用</span><br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>缓存后如何获取数据</p></li></ol><ul><li><p><strong>beforeRouteEnter</strong><br>每次组件渲染的时候都会执行beforeRouterEnter</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;<br>  <span class="hljs-title function_">next</span>(<span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> &#123;<br>    vm.<span class="hljs-title function_">getData</span>()<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>activated</strong><br>在keep-alive缓存中激活时执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">activated</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getData</span>()<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="12-nextTick-有什么用？"><a href="#12-nextTick-有什么用？" class="headerlink" title="12. nextTick()有什么用？"></a>12. nextTick()有什么用？</h2><p>等待下一次 DOM 更新刷新的工具方法。</p><ul><li>当你在 Vue 中更改响应式状态时，最终的 DOM 更新并不是同步生效的，而是由 Vue 将它们缓存在一个队列中，直到下一个“tick”才一起执行。这样是为了确保每个组件无论发生多少状态改变，都仅执行一次更新。</li><li>nextTick() 可以在状态改变后立即使用，以等待 DOM 更新完成。你可以传递一个回调函数作为参数，或者 await 返回的 Promise。</li></ul><h2 id="13-vue3-组件通信方案"><a href="#13-vue3-组件通信方案" class="headerlink" title="13. vue3 组件通信方案"></a>13. vue3 组件通信方案</h2><ol><li><strong>Props （父传子）</strong></li></ol>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html">// Parent.vue<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 使用子组件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;message&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>// Child.vue<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">msg</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props.<span class="hljs-property">msg</span>) </span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    &#123;&#123; msg &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>emits (子组件通知父组件触发一个事件，并且可以传值给父组件)</strong></li></ol>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html">// Parent.vue<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>父组件：&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 自定义 changeMsg 事件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> @<span class="hljs-attr">changeMsg</span>=<span class="hljs-string">&quot;changeMessage&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>// Child.vue<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 注册一个自定义事件名，向上传递时告诉父组件要触发的事件。</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;changeMsg&#x27;</span>])</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-comment">// 参数1：事件名</span></span><br><span class="language-javascript">  <span class="hljs-comment">// 参数2：传给父组件的值</span></span><br><span class="language-javascript">  <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;changeMsg&#x27;</span>, <span class="hljs-string">&#x27;扶苏&#x27;</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    子组件：<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>子组件的按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>ref 与 $parent</strong></li></ol><ul><li>ref 可以获取元素的 DOM 或者获取子组件实例的 VC。既然可以在父组件内部通过 ref 获取子组件实例 VC，那么子组件内部的方法与响应式数据父组件也是可以使用的。</li><li>$parent 可以获取某一个组件的父组件实例 VC，因此可以使用父组件内部的数据与方法。必须子组件内部拥有一个按钮点击时候获取父组件实例，当然父组件的数据与方法需要通过 defineExpose 方法对外暴露。</li></ul>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs html">// Parent.vue<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> money = <span class="hljs-title function_">ref</span>(<span class="hljs-number">10000</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> children1 = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> children2 = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">  money.<span class="hljs-property">value</span> += <span class="hljs-number">100</span>;</span><br><span class="language-javascript">  children1.<span class="hljs-property">value</span>.<span class="hljs-property">money</span> -= <span class="hljs-number">100</span>;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是父组件:ref parent<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>父组件拥有财产:&#123;&#123; money &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handler&quot;</span>&gt;</span>向子组件1拿100元<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Children1</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;children1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Children1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Children2</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;children2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Children2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>// Child1.vue<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;children1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是子组件1<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>子组件1拥有财产:&#123;&#123; money &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> money = <span class="hljs-title function_">ref</span>(<span class="hljs-number">9999</span>);</span><br><span class="language-javascript"><span class="hljs-title function_">defineExpose</span>(&#123;</span><br><span class="language-javascript">  money,</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>// Child2.vue<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;children2&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是子组件2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>子组件2拥有财产:&#123;&#123; money &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handler($parent)&quot;</span>&gt;</span>向父组件拿300元<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> money = <span class="hljs-title function_">ref</span>(<span class="hljs-number">9999</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params">$parent</span>) =&gt; &#123;</span><br><span class="language-javascript">  money.<span class="hljs-property">value</span> += <span class="hljs-number">300</span>;</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($parent);</span><br><span class="language-javascript">  $parent.<span class="hljs-property">money</span> -= <span class="hljs-number">300</span>;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>useAttrs</strong></li><li><strong>v-model</strong><br>组件上的 v-model 使用 modelValue 作为 prop 和 update:modelValue 作为事件。</li></ol>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html">// Parent.vue<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Child.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> message1 = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;1&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> message2 = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;2&#x27;</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">v-model:msg1</span>=<span class="hljs-string">&quot;message1&quot;</span> <span class="hljs-attr">v-model:msg2</span>=<span class="hljs-string">&quot;message2&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>// Child.vue<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-comment">// 接收</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">msg1</span>: <span class="hljs-title class_">String</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">msg2</span>: <span class="hljs-title class_">String</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;update:msg1&#x27;</span>, <span class="hljs-string">&#x27;update:msg2&#x27;</span>])</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">changeMsg1</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;update:msg1&#x27;</span>, <span class="hljs-string">&#x27;鲨鱼辣椒&#x27;</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">changeMsg2</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;update:msg2&#x27;</span>, <span class="hljs-string">&#x27;蝎子莱莱&#x27;</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeMsg1&quot;</span>&gt;</span>修改msg1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> &#123;&#123;msg1&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeMsg2&quot;</span>&gt;</span>修改msg2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> &#123;&#123;msg2&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="6"><li><strong>作用域插槽 slot</strong></li></ol>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html">// Parent.vue<br><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">header</span>=<span class="hljs-string">&quot;headerProps&quot;</span>&gt;</span><br>    &#123;&#123; headerProps &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>=<span class="hljs-string">&quot;defaultProps&quot;</span>&gt;</span><br>    &#123;&#123; defaultProps &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>=<span class="hljs-string">&quot;footerProps&quot;</span>&gt;</span><br>    &#123;&#123; footerProps &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">MyComponent</span>&gt;</span><br><br>// Child.vue<br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>//headerProps 的结果是 &#123; message: &#x27;hello&#x27; &#125;。<br></code></pre></td></tr></table></figure><ol start="7"><li><strong>provide &#x2F; inject</strong></li></ol><ul><li><p>遇到多层传值时，使用 props 和 emit 的方式会显得比较笨拙。这时就可以用 provide 和 inject 了。</p></li><li><p>provide 是在父组件里使用的，可以往下传值。</p></li><li><p>inject 是在子(后代)组件里使用的，可以网上取值。</p></li><li><p>无论组件层次结构有多深，父组件都可以作为其所有子组件的依赖提供者。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs html">// Parent.vue<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, provide, readonly &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Child.vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;1&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> msg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;2&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 使用readonly可以让子组件无法直接修改，需要调用provide往下传的方法来修改</span></span><br><span class="language-javascript"><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-title function_">readonly</span>(name))</span><br><span class="language-javascript"><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;msg&#x27;</span>, msg)</span><br><span class="language-javascript"><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;changeName&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">  name.<span class="hljs-property">value</span> = value</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>// Child.vue<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>msg: &#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>name: &#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>修改<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-comment">// 参数2为默认值</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> msg = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;msg&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> changeName = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;changeName&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">changeName</span>(<span class="hljs-string">&#x27;3&#x27;</span>)</span><br><span class="language-javascript">  <span class="hljs-comment">// 因为 msg 没被 readonly 过，所以可以直接修改值</span></span><br><span class="language-javascript">  msg.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;4&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><ol start="8"><li><strong>getCurrentInstance</strong></li><li><strong>mitt.js</strong></li><li><strong>Pinia</strong></li></ol><h2 id="14-v-model原理"><a href="#14-v-model原理" class="headerlink" title="14. v-model原理"></a>14. v-model原理</h2><p>v-model是一个指令用于双向绑定。<br><strong>原理</strong>：</p><ul><li>在模板中用v-model绑定一个变量到表单元素上</li><li>vue在解析模板时，会将v-model指令转换为合适的属性和事件绑定。对于大多数表单元素，他会将value属性于输入框的当前值进行绑定，并监听inbput事件来实时更新绑定的数据。</li><li>当用户在输入框中键入或选择内容时，会触发Input事件。Vue会捕获该事件并更新绑定的数据，以及根据数据的变化重新渲染视图。</li><li>同样，如果在表单元素上使用v-model的lazy修饰符，vue会监听change事件，而不是input事件。<br>总的来说，原理就是通过监听表单元素的输入事件，将用户的输入同步到vue实例中的属性，并在属性值变化时重新渲染视图。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端面试-性能优化篇</title>
    <link href="/2025/09/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/"/>
    <url>/2025/09/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="1-怎么实现大文件的上传？"><a href="#1-怎么实现大文件的上传？" class="headerlink" title="1. 怎么实现大文件的上传？"></a>1. 怎么实现大文件的上传？</h2><ul><li>分片上传(Chunked Upload):将大文件拆分成小的文件块(chunk)，然后通过多个并行的请求依次上传这些文件块。服务器接收到每个文件块后进行存储，最后合并所有文件块以还原原始文件。这种方法可以降低单个请求的负载，并允许在网络中断或上传失败时可以从断点续传。</li><li>流式上传(Streaming Upload):客户端使用流方式逐步读取文件的内容，并将数据流通过 POST 请求发送给服务器。服务器端能够逐步接收并处理这些数据流，而无需等待完整的文件上传完成。这种方法适用于较大的文件，减少了内存占用和传输延迟。</li><li>使用专门的文件上传服务:有一些第三方服务可供使用，例如云存储服务(如 Amazon S3、Google cloud3.Storage)、文件传输协议(如 FTP、SFTP)等。这些服务通常提供了高可靠性、可扩展性和安全性，并且针对大文件上传进行了优化。</li><li>压缩文件上传:如果可能，可以在客户端先对文件进行压缩，然后再进行上传。压缩后的文件大小更小，可以减少上传时间和网络带宽消耗。</li><li>并发上传:通过多个并行的请求同时上传文件的不同部分，以加快整个上传过程。这需要服务器端支持并发上传并正确处理分片或部分文件的合并。</li><li>断点续传:记录上传进度和状态，以便在网络中断或上传失败后能够从上次中断的位置继续上传。可以使用客户端或服务器端的断点续传机制来实现。</li></ul><h2 id="2-说说常规的前端性能优化手段？"><a href="#2-说说常规的前端性能优化手段？" class="headerlink" title="2. 说说常规的前端性能优化手段？"></a>2. 说说常规的前端性能优化手段？</h2><ul><li>content 方面<ul><li>减少HTTP请求：合并文件、CSS精灵、inline Image</li><li>减少DNS查询： DNS查询完成之前浏览器不能从这个主机下载任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS拆线呢</li><li>避免重定向：多余的中间件访问</li><li>使用Ajax可缓存</li><li>非必须组件延迟加载</li><li>未来所需组件预先加载</li><li>减少DOM元素数量</li><li>将资源放到不同域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量</li><li>减少iframe数量</li></ul></li><li>Server 方面<ul><li>使用CDN</li><li>添加Expires或者Cache-Conntrol响应头</li><li>对组件使用Gzip压缩</li><li>配置ETag</li><li>Flush Buffer Early</li><li>Ajax使用GET进行请求</li><li>避免空链接</li></ul></li><li>Cookie方面<ul><li>减少cookie大小</li><li>引入资源的域名不要包含cookie</li></ul></li><li>CSS 方面<ul><li>将样式表放到页面顶部</li><li>不适用CSS表达式</li><li>不使用IE的Filter</li></ul></li><li>JS 方面<ul><li>将脚本放到页面底部</li><li>将JS和CSS外部引入</li><li>压缩JS CSS</li><li>删除不需要的脚本</li><li>减少对DOM的访问</li><li>合理设计事件监听器</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端面试-工程化篇</title>
    <link href="/2025/09/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%AF%87/"/>
    <url>/2025/09/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是Vite"><a href="#1-什么是Vite" class="headerlink" title="1. 什么是Vite?"></a>1. 什么是Vite?</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端面试-HTTP篇</title>
    <link href="/2025/09/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-HTTP%E7%AF%87/"/>
    <url>/2025/09/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-HTTP%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="1-websocket和http的区别"><a href="#1-websocket和http的区别" class="headerlink" title="1.websocket和http的区别"></a>1.websocket和http的区别</h2><h3 id="使用场景对比"><a href="#使用场景对比" class="headerlink" title="使用场景对比"></a>使用场景对比</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><ul><li>HTTP（Hypertext Transfer Protocol）是一种应用层协议，最初设计用于在客户端和服务器之间传输超文本。它是一种无状态的协议，每个请求都是独立的，不保留前一次请求的状态信息。HTTP 通常用于传输网页、图片、文本等静态资源，以及通过 RESTful API 进行数据传输。</li></ul><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><ul><li>WebSocket 是一种全双工通信协议，建立在单个 TCP 连接上，允许在客户端和服务器之间进行双向通信。WebSocket 的设计旨在解决 HTTP 协议在实时性和交互性方面的不足。它广泛应用于实时聊天、在线游戏、金融行业的实时数据更新等场景。</li></ul><h3 id="协议对比"><a href="#协议对比" class="headerlink" title="协议对比"></a>协议对比</h3><h4 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP"></a>HTTP</h4><ul><li>协议类型： 无状态、请求-响应型协议。</li><li>通信方式： 单向通信，客户端发送请求，服务器返回响应。</li><li>持久连接： 支持持久连接，通过 HTTP Keep-Alive 头字段可以在一次连接中发送多个请求和响应。</li></ul><h4 id="WebSocket-1"><a href="#WebSocket-1" class="headerlink" title="WebSocket"></a>WebSocket</h4><ul><li>协议类型： 全双工通信协议。</li><li>通信方式： 双向通信，客户端和服务器可以随时发送消息。</li><li>持久连接： 基于单个 TCP 连接，保持连接状态，避免了每次通信都需要重新建立连接的开销。</li></ul><h3 id="链接方式对比"><a href="#链接方式对比" class="headerlink" title="链接方式对比"></a>链接方式对比</h3><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP"></a>HTTP</h4><ul><li>连接建立： 每个请求都需要建立一个新的连接。</li><li>连接关闭： 服务器在每个响应之后会关闭连接，客户端需要重新建立连接发送新的请求。</li></ul><h4 id="WebSocket-2"><a href="#WebSocket-2" class="headerlink" title="WebSocket"></a>WebSocket</h4><ul><li>连接建立： 通过 HTTP 协议建立初始连接，然后升级为 WebSocket 协议。建立连接后保持开放状态。</li><li>连接关闭： 可以由客户端或服务器发起关闭连接请求，而不需要重新建立连接。</li></ul><h3 id="通信性质对比"><a href="#通信性质对比" class="headerlink" title="通信性质对比"></a>通信性质对比</h3><h4 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP"></a>HTTP</h4><ul><li>单向通信： 请求-响应模式，客户端发送请求，服务器返回响应。</li><li>轮询： 实现实时性的方式之一是通过轮询，但效率低，增加了网络负担。</li></ul><h4 id="WebSocket-3"><a href="#WebSocket-3" class="headerlink" title="WebSocket"></a>WebSocket</h4><ul><li>双向通信： 客户端和服务器可以随时发送消息，实现实时的双向通信。</li><li>事件驱动： 基于事件的模型，服务器或客户端可以通过事件触发实现及时的通信。</li></ul><h2 id="2-前端跨页面通信的方法？"><a href="#2-前端跨页面通信的方法？" class="headerlink" title="2. 前端跨页面通信的方法？"></a>2. 前端跨页面通信的方法？</h2><ul><li>LocalStorage 或 SessionStorage:这两个 Web 存储 API 可以在不同页面之间共享数据。一个页面可以将数据存储在本地存储中，另一个页面则可以读取该数据并进行相应处理。通过监听 storage 事件，可以实现数据的实时更新。</li><li>Cookies:使用 Cookies 也可以在不同页面之间传递数据。通过设置和读取 Cookie 值，可以在同一域名下的不司页面之间交换信息。</li><li>PostMessage: window.postMessage()方法允许从一个窗口向另一个窗口发送消息，并在目标窗口上触发.message 事件。通过指定目标窗口的 origin，可以确保只有特定窗口能够接收和处理消息。</li><li>Broadcast Channel:Broadcast Channel API 允许在同一浏览器下的不同上下文(例如，在不同标签页或iframe 中)之间进行双向通信。它提供了一个类似于发布-订阅模式的机制，通过创建一个广播频道，并在不同上下文中加入该频道，可以实现消息的广播和接收。</li><li>SharedWorker:sharedWorker 是一个可由多个窗口或标签页共享的 Web Worker，它可以在不同页面之间进行跨页面通信。通过 SharedWorker，多个页面可以通过 postMessage 进行双向通信，并共享数据和执行操作。</li><li>IndexedDB:IndexedDB 是浏览器提供的一个客户端数据库，可以在不同页面之间存储和共享数据。通过在一个页面中写入数据，另一个页面可以读取该数据。</li><li>WebSockets:WebSockets 提供了全双工的、双向通信通道，可以在客户端和服务器之间进行实时通信。通过建立 WebSocket 连接，可以在不同页面之间通过服务器传递数据并实现实时更新。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端面试-js篇</title>
    <link href="/2025/08/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-js%E7%AF%87/"/>
    <url>/2025/08/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-js%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="1-js中的数据类型？"><a href="#1-js中的数据类型？" class="headerlink" title="1.js中的数据类型？"></a>1.js中的数据类型？</h2><ol><li>number、string、boolean、null、undefined、object、symbol<br>（symbol 是 ES6 新增的数据类型，用于创建唯一标识符。）、bigint</li><li>引用数据类型: 对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function）</li></ol><hr><h2 id="2-0-1-0-2-x3D-0-3-的结果是多少？"><a href="#2-0-1-0-2-x3D-0-3-的结果是多少？" class="headerlink" title="2. 0.1 + 0.2 &#x3D; 0.3 的结果是多少？"></a>2. 0.1 + 0.2 &#x3D; 0.3 的结果是多少？</h2><p>0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004.</p><h2 id="3-typeof能否判断正确类型？"><a href="#3-typeof能否判断正确类型？" class="headerlink" title="3.typeof能否判断正确类型？"></a>3.typeof能否判断正确类型？</h2><p>typeof 1 返回 number<br>typeof ‘1’ 返回 string<br>typeof true 返回 boolean<br>typeof undefined 返回 undefined<br>typeof symbol() 返回 symbol</p><p>但对于引用数据类型，typeof 无法判断正确的类型，除了函数之外，都会显示object<br>typeof {} 返回 object<br>typeof [] 返回 object<br>typeof console.log 返回 function</p><h2 id="4-instanceof-？"><a href="#4-instanceof-？" class="headerlink" title="4. instanceof ？"></a>4. instanceof ？</h2><p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。<br>instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true。</p><h2 id="5-typeof-和instanceof-区别？"><a href="#5-typeof-和instanceof-区别？" class="headerlink" title="5. typeof 和instanceof 区别？"></a>5. typeof 和instanceof 区别？</h2><p>typeof与instanceof都是判断数据类型的方法，区别如下：</p><ul><li>typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值。</li><li>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型。</li><li>而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断。</li></ul><h2 id="6-手动实现一个instanceof"><a href="#6-手动实现一个instanceof" class="headerlink" title="6.手动实现一个instanceof"></a>6.手动实现一个instanceof</h2><p>核心：获取对象的原型，判断对象的原型是否等于构造函数的 prototype 对象。原型链的向上查找。</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params">left, right</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> left !== <span class="hljs-string">&#x27;object&#x27;</span> || left === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(left);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (proto === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (proto === right.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">myInstanceof</span>(<span class="hljs-string">&#x27;111&#x27;</span>, <span class="hljs-title class_">String</span>)); <span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">myInstanceof</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;111&#x27;</span>), <span class="hljs-title class_">String</span>)); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><hr><h2 id="7-object-is和-x3D-x3D-x3D-区别？"><a href="#7-object-is和-x3D-x3D-x3D-区别？" class="headerlink" title="7.object.is和&#x3D;&#x3D;&#x3D;区别？"></a>7.object.is和&#x3D;&#x3D;&#x3D;区别？</h2><ul><li>NaN 和 NaN 相等</li><li>0 和 -0 不相等</li></ul><hr><h2 id="8-js类型转换？"><a href="#8-js类型转换？" class="headerlink" title="8. js类型转换？"></a>8. js类型转换？</h2><p>三种：</p><ul><li>转换成数字</li><li>转换成布尔值</li><li>转换成字符串</li></ul><p><img src="/2025/08/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-js%E7%AF%87/8-1.png" alt=" "></p><h2 id="9-x3D-x3D-x3D-和-x3D-x3D-的区别？"><a href="#9-x3D-x3D-x3D-和-x3D-x3D-的区别？" class="headerlink" title="9. &#x3D;&#x3D;&#x3D; 和 &#x3D;&#x3D; 的区别？"></a>9. &#x3D;&#x3D;&#x3D; 和 &#x3D;&#x3D; 的区别？</h2><p><code>===</code> 严格相等，左右两边不仅值要相等，类型也要相等。<br><code>==</code> 允许类型转换，只要两边的值相等，就返回true。</p><p><code>==</code>不像 <code>===</code>那样严格，对于一般情况，只要值相等，就返回true，但&#x3D;&#x3D;还涉及一些类型转换，它的转换规则如下：</p><ul><li>两边的类型是否相同，相同的话就比较值的大小，例如1&#x3D;&#x3D;2，返回false。</li><li>判断的是否是null和undefined，是的话就返回true。</li><li>判断的类型是否是String和Number，是的话，把String类型转换成Number，再进行比较。</li><li>判断其中一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较。</li><li>如果其中一方为Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较。</li></ul><h2 id="10-js闭包？"><a href="#10-js闭包？" class="headerlink" title="10. js闭包？"></a>10. js闭包？</h2><p>概念：闭包是指有权访问另一个函数作用域中的变量的函数。闭包&#x3D;函数+词法环境。闭包就是能够读取其他函数内部变量的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">m</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">sub</span>(<span class="hljs-params"></span>)&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>特性：</p><ul><li>函数内再嵌套函数</li><li>内部函数可以引用外层的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ul><p>表现形式：</p><ol><li><p>返回一个函数</p></li><li><p>作为函数参数传递</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">m</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">sub</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>    &#125;<br>    <span class="hljs-title function_">bar</span>(sub);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">fn</span>)&#123;<br>    <span class="hljs-title function_">fn</span>();<br>&#125;<br><span class="hljs-title function_">m</span>();<span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure></li><li><p>在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定时器</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timeHandler</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;111&#x27;</span>);<br>&#125;，<span class="hljs-number">100</span>)<br><span class="hljs-comment">// 事件监听</span><br>$(<span class="hljs-string">&#x27;#app&#x27;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;DOM Listener&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>IIFE(立即执行函数表达式)创建闭包, 保存了 全局作用域window 和 当前函数的作用域 ，因此可以全局的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">// 输出2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>&#125;)();<br></code></pre></td></tr></table></figure></li></ol><p>理解：</p><ul><li>使用闭包主要是为了设计私有的⽅法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增⼤内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产⽣作用域的概念。</li><li>闭包 的最⼤用处有两个，⼀个是可以读取函数内部的变量，另⼀个就是让这些变量始终保持在内存中。</li><li>闭包的另⼀个用处，是封装对象的私有属性和私有⽅法</li><li>好处：能够实现封装和缓存等；</li><li>坏处：就是消耗内存、不正当使用会造成内存溢出的问题</li></ul><p>注意点：</p><ul><li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很⼤，所以不能滥用闭包，否则会造成网⻚的性能问题，在IE中可能导致内存泄露。</li><li>解决⽅法是，在退出函数之前，将不使用的局部变量全部删除</li></ul><hr><h2 id="11-原型对象和构造函数的关系？"><a href="#11-原型对象和构造函数的关系？" class="headerlink" title="11.原型对象和构造函数的关系？"></a>11.原型对象和构造函数的关系？</h2><p>每当定义一个函数数据类型（普通函数、类）时候，会天生自带一个prototype属性，这个属性指向函数的原型对象。<br>当函数经过new调用时，这个函数就成了构造函数，会返回一个全新的实例对象，这个实例对象有proto属性，指向构造函数的原型对象。</p><hr><h2 id="12-原型链"><a href="#12-原型链" class="headerlink" title="12. 原型链"></a>12. 原型链</h2><p><img src="/2025/08/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-js%E7%AF%87/12-1.png" alt=" "></p><hr><h2 id="13-this对象？"><a href="#13-this对象？" class="headerlink" title="13. this对象？"></a>13. this对象？</h2><ul><li>this总是指向函数的直接调用者（而非间接调用者）</li><li>如果有 new 关键字， this 指向 new 出来的那个对象</li><li>在事件中， this 指向触发这个事件的对象，特殊的是， IE 中的 attachEvent 中的this 总是指向全局对象 Window</li></ul><hr><h2 id="14-js继承"><a href="#14-js继承" class="headerlink" title="14. js继承"></a>14. js继承</h2><p><a href="https://blog.csdn.net/wtswts1232/article/details/130683362">继承</a>：子类继承父类的属性和方法，并扩展新的属性和方法<br>继承的实现方式：原型链、对象组合、类继承、组合继承、寄生组合继承</p><ol><li><p>原型链继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;parent&quot;</span>;<br>&#125;<br><span class="hljs-comment">// 在父类的原型上定义方法</span><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-comment">// 定义子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;child&quot;</span>;<br>&#125;<br><span class="hljs-comment">// 子类继承父类，这里是关键，实现原型链继承</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><span class="hljs-comment">// 实例化子类</span><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 输出 &quot;child&quot;</span><br></code></pre></td></tr></table></figure><p>缺点：</p><ul><li>父类引用属性被所有子类实例共享。如果一个实例改变了该属性，那么其他实例的该属性也会被改变。</li></ul></li><li><p>构造函数继承：<br>通过使用call或者apply方法,可以在子类中执行父类的构造函数，从而实现继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">    <span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>&#125;;<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-string">&quot;我是父类prototype上的属性&quot;</span>;<br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 创建两个 Child 实例</span><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><span class="hljs-keyword">var</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-property">sayHello</span> === child2.<span class="hljs-property">sayHello</span>); <span class="hljs-comment">// 输出 false</span><br></code></pre></td></tr></table></figure><p>优点：不会出现原型链继承出现的问题。<br>缺点：它不能继承父类 prototype 上的属性</p></li><li><p>组合继承</p><p>原型链继承 + 构造函数继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>&#125;;<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-string">&quot;我是父类prototype上的属性&quot;</span>; <br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br></code></pre></td></tr></table></figure><p>优点：解决了构造继承的问题<br>缺点：调用了 2 次 Parent()。 它在 child 的 prototype 上添加了父类的属性和方法。</p></li><li><p>寄生组合继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">   <span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-string">&quot;我是父类prototype上的属性&quot;</span>;<br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><br><span class="hljs-comment">// 创建一个没有实例方法的父类实例作为子类的原型</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-comment">// 修复构造函数的指向</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>;<br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br></code></pre></td></tr></table></figure><p>object.create(Parent.prototype)  创造了一个空对象，这个空对象的__proto__ 是 Parent.prototype 。所以它继承了 Parent 原型链上的属性和方法。由于我们删除了Child.prototype &#x3D; new Parent(); 我们不再调用 Parent() 构造函数，因此 Child.prototype 不再包含 Parent 的属性和方法。所以第三小节部分提到的问题就解决了，Child.prototype 上不再有 sayHello 方法。<br>优点：</p><ul><li>原型属性不会被共享</li><li>可以继承父类的属性和方法</li><li>只调用1次Parent(),因此它不会再child的prototype上添加Parent的属性和方法<br>缺点：<br>child.prototype的原始属性和方法会丢失</li></ul></li></ol><hr><h2 id="15-js浅拷贝和深拷贝"><a href="#15-js浅拷贝和深拷贝" class="headerlink" title="15. js浅拷贝和深拷贝"></a>15. js浅拷贝和深拷贝</h2><p>JS 分为原始类型和引用类型，对于原始类型的拷贝，并没有深浅拷贝的区别，我们讨论的深浅拷贝都只针对引用类型。</p><ul><li>浅拷贝和深拷贝都复制了值和地址，都是为了解决引用类型赋值后互相影响的问题。</li><li>但是浅拷贝只进行一层复制，深层次的引用类型还是共享内存地址，原对象和拷贝对象还是会互相影响。</li><li>深拷贝就是无限层级拷贝，深拷贝后的原对象不会和拷贝对象互相影响。</li></ul><h3 id="浅拷贝手段"><a href="#浅拷贝手段" class="headerlink" title="浅拷贝手段"></a>浅拷贝手段</h3><ol><li><p>手动实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">shallowClone</span> = (<span class="hljs-params">target</span>) =&gt; &#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="hljs-literal">null</span>) &#123;<br>     <span class="hljs-keyword">const</span> cloneTarget = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) ? []: &#123;&#125;;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> target) &#123;<br>         <span class="hljs-keyword">if</span> (target.<span class="hljs-title function_">hasOwnProperty</span>(prop)) &#123;<br>             cloneTarget[prop] = target[prop];<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> cloneTarget;<br> &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">return</span> target;<br> &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li><li><p>object.assign()<br>Object.assign() 拷贝的是对象的属性的引用，而不是对象本身。<br>Object.assign 只会拷⻉所有的属性值到新的对象中，如果属性值是对象的话，拷⻉的是地址，所以并不是深拷⻉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sy&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sss&#x27;</span>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2);<span class="hljs-comment">//&#123; name: &#x27;sss&#x27;, age: 18 &#125;</span><br></code></pre></td></tr></table></figure></li><li><p>concat</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">concat</span>();<br>newArr[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[ 1, 2, 3 ]</span><br></code></pre></td></tr></table></figure></li><li><p>slice</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">concat</span>();<br>newArr[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[ 1, 2, 3 ]</span><br></code></pre></td></tr></table></figure></li><li><p>…展开运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> newArr = [...arr];<span class="hljs-comment">//跟arr.slice()是一样的效果</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="深拷贝手段"><a href="#深拷贝手段" class="headerlink" title="深拷贝手段"></a>深拷贝手段</h3><ol><li>JSON.parse(JSON.stringify())<br>这种方法虽然可以实现数组或对象深拷贝，但不能处理函数对象或undefined（会显示为null）；结构复杂的数据function、undefined、Symbol会被过滤掉。</li><li>lodash库 cloneDeep()</li></ol><hr><h2 id="16-事件代理？"><a href="#16-事件代理？" class="headerlink" title="16. 事件代理？"></a>16. 事件代理？</h2><p>事件代理，也叫事件委托，是事件处理机制的一种，事件代理的原理是把事件绑定在父元素上，然后通过事件冒泡，把事件传递给子元素。<br>事件的发生经历三个阶段：捕获阶段（ capturing ）、目标阶段<br>（ targetin ）、冒泡阶段（ bubbling ）<br>适合事件委托的事件有：click，mousedown，mouseup，keydown，keyup，keypress。<br>从上面应用场景中，我们就可以看到使用事件委托存在两大优点：</p><ul><li>减少整个页面所需的内存，提升整体性能</li><li>动态绑定，减少重复工作</li></ul><p>但是使用事件委托也是存在局限性：</p><ul><li>focus、blur这些事件没有事件冒泡机制，所以无法进行委托绑定事件</li><li>mousemove、mouseout这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的</li></ul><h2 id="17-new操作符都干了什么？"><a href="#17-new操作符都干了什么？" class="headerlink" title="17. new操作符都干了什么？"></a>17. new操作符都干了什么？</h2><ul><li>创建⼀个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型</li><li>属性和⽅法被加⼊到 this 引用的对象中</li><li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li></ul><h2 id="18-谈谈你对ES6的理解"><a href="#18-谈谈你对ES6的理解" class="headerlink" title="18. 谈谈你对ES6的理解"></a>18. 谈谈你对ES6的理解</h2><ul><li>新增模板字符串（为 JavaScript 提供了简单的字符串插值功能）</li><li>箭头函数</li><li>for-of （用来遍历数据—例如数组中的值。）</li><li>arguments 对象可被不定参数和默认参数完美代替。</li><li>ES6 将promise 对象纳⼊规范，提供了原⽣的 Promise 对象。</li><li>增加了 let 和 const 命令，用来声明变量。</li><li>增加了块级作用域。</li><li>let 命令实际上就增加了块级作用域。</li><li>还有就是引⼊ module 模块的概念。</li></ul><hr><h2 id="19-let-var-const区别？"><a href="#19-let-var-const区别？" class="headerlink" title="19. let var const区别？"></a>19. let var const区别？</h2><ol><li><p>作用域区别<br>let和const具有块级作用域，var不存在块级作用域,可以跨块访问, 不能跨函数访问</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> b = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">const</span> c = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c);<br><span class="hljs-comment">//0，这里只有var声明的变量才能打印出来，因为var声明的事全局变量</span><br></code></pre></td></tr></table></figure><p>var出来的变量是全局的，但是不能跨函数访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;zimo&quot;</span>;   <span class="hljs-comment">// 局部变量</span><br>&#125;<br><span class="hljs-title function_">test</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);  <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure></li><li><p>变量提升<br>变量能在声明之前使用，就是变量提升。<br>var存在变量提升，let和const不存在变量提升</p></li><li><p>全局属性<br>浏览器的全局对象是window。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span><br><span class="hljs-keyword">const</span> c = <span class="hljs-number">3</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">a</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">b</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">c</span>);<br><span class="hljs-comment">//1,undefined,undefined</span><br></code></pre></td></tr></table></figure></li><li><p>重复声明<br>var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</p></li><li><p>暂时性死区<br>在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。但是访问时会undefined</p></li><li><p>初始值设置<br>在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</p></li><li><p>指针指向<br>指针指向：let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p></li><li><p>应用场景<br>声明对象类型使用 const，非对象类型声明选择 let</p></li></ol><h2 id="20-Dom-操作"><a href="#20-Dom-操作" class="headerlink" title="20. Dom 操作"></a>20. Dom 操作</h2><ol><li><p>创建节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">createDocumentFragment</span>() <span class="hljs-comment">//创建⼀个DOM⽚段</span><br><span class="hljs-title function_">createElement</span>() <span class="hljs-comment">//创建⼀个具体的元素</span><br><span class="hljs-title function_">createTextNode</span>() <span class="hljs-comment">//创建⼀个文本节点</span><br></code></pre></td></tr></table></figure></li><li><p>添加、移除、替换、插入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">appendChild</span>() <span class="hljs-comment">//添加</span><br><span class="hljs-title function_">removeChild</span>() <span class="hljs-comment">//移除</span><br><span class="hljs-title function_">replaceChild</span>() <span class="hljs-comment">//替换</span><br><span class="hljs-title function_">insertBefore</span>() <span class="hljs-comment">//插⼊</span><br></code></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">getElementsByTagName</span>() <span class="hljs-comment">//通过标签名称</span><br><span class="hljs-title function_">getElementsByName</span>() <span class="hljs-comment">//通过元素的Name属性的值</span><br><span class="hljs-title function_">getElementById</span>() <span class="hljs-comment">//通过元素Id，唯⼀性</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="21-防抖与节流"><a href="#21-防抖与节流" class="headerlink" title="21. 防抖与节流"></a>21. 防抖与节流</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>为了防止快速且频繁的触发事件而导致多次执行事件函数，我们这多次触发的事件只执行一次事件函数。<br>手动实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">debounce</span> = (<span class="hljs-params">func, wait</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> timer<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer)<br>      timer = <span class="hljs-built_in">setTimeout</span>(func, wait);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数防抖在执行目标方法时，会等待一段时间。当又执行相同方法时，若前一个定时任务未执行完，则 清除掉定时任务，重新定时。<br>对于按钮防点击来说的实现</p><ul><li>开始⼀个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。⼀旦定时器结束并设置为 null，就可以再次点击了</li><li>对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果⼩于需要的时间间隔，就会重新创建⼀个定时器，并且定时器的延时为设定时间减去之前的时间间隔。⼀旦时间到了，就会执行相应的回调函数</li></ul><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>防抖动和节流本质是不⼀样的。防抖动是将多次执行变为最后⼀次执行，节流<br>是将多次执行变成每隔⼀段时间执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">throttle</span> = (<span class="hljs-params">func, wait</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> timer;<br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (timer) &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">func</span>();<br>            timer = <span class="hljs-literal">null</span><br>        &#125;, wait)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数节流的目的，是为了限制函数一段时间内只能执行一次。因此，通过使用定时任务，延时方法执行。在延时的时间内，方法若被触发，则直接退出方法。从而实现一段时间内只执行一次。</p><h3 id="异同比较"><a href="#异同比较" class="headerlink" title="异同比较"></a>异同比较</h3><p>相同点：</p><ul><li>都可以通过使用 setTimeout 实现</li><li>目的都是，降低回调函数的执行频率，节省计算资源<br>不同点：</li><li>函数防抖，是在一段连续操作结束之后，处理回调，利用 clearTimout 和 setTimeout 实现。</li><li>函数节流，是在一段连续操作中，每一段时间只执行一次，在频率较高的事件中使用来提高性能。</li><li>函数防抖关注一段时间内连续触发，只在最后一次执行；而函数节流侧重于在一段时间内只执行一次。</li></ul><hr><h2 id="22-事件流"><a href="#22-事件流" class="headerlink" title="22. 事件流"></a>22. 事件流</h2><p>事件流分为两种，捕获事件流和冒泡事件流</p><ul><li>捕获事件流从根节点开始执行，⼀直往⼦节点查找执行，直到查找执行到目标节点</li><li>冒泡事件流从目标节点开始执行，⼀直往父节点冒泡查找执行，直到查到到根节点</li><li>事件流分为三个阶段，⼀个是捕获节点，⼀个是处于目标节点阶段，⼀个是冒泡阶段</li></ul><hr><h2 id="23-描述一下this"><a href="#23-描述一下this" class="headerlink" title="23. 描述一下this"></a>23. 描述一下this</h2><p>this ，函数执行的上下文，可以通过 apply ， call ， bind 改变 this<br>的指向。对于匿名函数或者直接调用的函数来说，this指向全局上下文（浏览器为window，NodeJS为 global ），剩下的函数调用，那就是谁调用它，this 就指向谁。当然还有es6的箭头函数，箭头函数的指向取决于该箭头函数声明的位置，在哪里声明， this 就指向哪里。</p><hr><h2 id="24-ajax、axios、fetch区别？"><a href="#24-ajax、axios、fetch区别？" class="headerlink" title="24. ajax、axios、fetch区别？"></a>24. ajax、axios、fetch区别？</h2><ol><li><p>jQuery ajax</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$.<span class="hljs-title function_">ajax</span>(&#123;<br>   <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>   <span class="hljs-attr">url</span>: url,<br>   <span class="hljs-attr">data</span>: data,<br>   <span class="hljs-attr">dataType</span>: dataType,<br>   <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;,<br>   <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>优缺点：</p><ul><li>本身是针对 MVC 的编程,不符合现在前端 MVVM 的浪潮</li><li>基于原⽣的 XHR 开发， XHR 本身的架构不清晰，已经有了 fetch 的替代⽅案</li></ul></li><li><p>axios</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">axios</span>(&#123;<br>   <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>   <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/user/12345&#x27;</span>,<br>   <span class="hljs-attr">data</span>: &#123;<br>   <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Fred&#x27;</span>,<br>   <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Flintstone&#x27;</span><br>   &#125;<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>优缺点：</p><ul><li>从浏览器中创建 XMLHttpRequest</li><li>从 node.js 发出 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>⾃动转换 JSON 数据</li><li>客户端支持防⽌ CSRF&#x2F;XSR</li></ul></li><li><p>fetch</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>   <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br>   <span class="hljs-keyword">let</span> data = response.<span class="hljs-title function_">json</span>();<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Oops, error&quot;</span>, e);<br>&#125;<br></code></pre></td></tr></table></figure><p>优缺点：</p><ul><li>fetch 只对网络请求报错，对 400,500 都当做成功的请求，需要封装去处理</li><li>fetch 默认不会带 cookie ，需要添加配置项</li><li>fetch 不支持 abort ，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻⽌请求过程继续在后台运行，造成了量的浪费</li><li>fetch 没有办法原⽣监测请求的进度，⽽XHR可以</li></ul></li></ol><hr><h2 id="25-js作用域和作用域链？"><a href="#25-js作用域和作用域链？" class="headerlink" title="25. js作用域和作用域链？"></a>25. js作用域和作用域链？</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>Javascript中的作用域说的是变量的可访问性和可见性。也就是说整个程序中哪些部分可以访问这个变量，或者说这个变量都在哪些地方可见。有三种作用域：全局作用域；函数作用域；块级作用域</p><ul><li>全局作用域<br>任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问。</li><li>函数作用域<br>函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问。</li><li>块级作用域<br>ES6引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-comment">// 块级作用域中的变量</span><br>  <span class="hljs-keyword">let</span> greeting = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<br>  <span class="hljs-keyword">var</span> lang = <span class="hljs-string">&#x27;English&#x27;</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting); <span class="hljs-comment">// Prints &#x27;Hello World!&#x27;</span><br>&#125;<br><span class="hljs-comment">// 变量 &#x27;English&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lang);<br><span class="hljs-comment">// 报错：Uncaught ReferenceError: greeting is not defined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);<br></code></pre></td></tr></table></figure><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>作用域链是指js引擎从变量或函数中查找变量或函数时，会从当前作用域开始，然后逐级向上查找，直到找到为止。</p><hr><h2 id="26-e-target和e-currentTarget区别？"><a href="#26-e-target和e-currentTarget区别？" class="headerlink" title="26. e.target和e.currentTarget区别？"></a>26. e.target和e.currentTarget区别？</h2><p>区别是，event.currentTarget( ) 会返回当前触发事件的元素；而event.target( ) 会返回触发事件触发的源头元素。</p><p>用法：可以用来监听触发事件的元素是否事件发生的源头元素。这个源头元素指的是，当我点击子元素，虽然父元素的点击事件也会被触发（冒泡机制），但子元素才是事件的源头元素。</p><h2 id="27-改变this指向的方法？"><a href="#27-改变this指向的方法？" class="headerlink" title="27. 改变this指向的方法？"></a>27. 改变this指向的方法？</h2><ol><li><p>bind()<br>bind方法会创建一个新的函数，并将其内部的this绑定到指定对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayhello</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><span class="hljs-keyword">const</span> person = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;john&quot;</span>&#125;;<br><span class="hljs-keyword">const</span> boundFunction = sayhello.<span class="hljs-title function_">bind</span>(person);<br><span class="hljs-title function_">boundFunction</span>();<span class="hljs-comment">//John</span><br></code></pre></td></tr></table></figure></li><li><p>箭头函数<br>箭头函数没有this，他会继承外部作用域的this。因此在箭头函数中使用this时候，他会指向定义时所在的上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>   <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;john&quot;</span>,<br>   <span class="hljs-attr">sayhello</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);&#125;,<span class="hljs-number">1000</span>);<br>   &#125;<br>&#125;<br>person.<span class="hljs-title function_">sayhello</span>();<span class="hljs-comment">//John</span><br></code></pre></td></tr></table></figure></li><li><p>call()或apply()</p><p>call()和apply()方法可以立即调用函数，并显式指定函数内部的this值，他们之间的区别在于参数的传递方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayhello</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><span class="hljs-keyword">const</span> person = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;john&quot;</span>&#125;;<br>sayhello.<span class="hljs-title function_">call</span>(person);<span class="hljs-comment">//John</span><br>sayhello.<span class="hljs-title function_">apply</span>(person);<span class="hljs-comment">//John</span><br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="28-为什么要区分宏任务和微任务？他们的执行优先级是什么？"><a href="#28-为什么要区分宏任务和微任务？他们的执行优先级是什么？" class="headerlink" title="28. 为什么要区分宏任务和微任务？他们的执行优先级是什么？"></a>28. 为什么要区分宏任务和微任务？他们的执行优先级是什么？</h2><p>宏任务和微任务是为了解决 JavaScript 引擎中不同任务之间的执行优先级问题。<br>宏任务通常包含以下几种：</p><ul><li>setTimeout()和setInterval()</li><li>DOM 事件处理程序</li><li>AJAX 请求</li><li>script标签的加载和执行</li></ul><p>对于宏任务，JS引擎会将其添加到任务队列中，在当前任务执行完毕后按顺序依次执行。<br>微任务通常包含以下几种：</p><ul><li>Promise 的then和catch方法回调函数</li><li>async&#x2F;await</li><li>MutationObserver 监听器</li></ul><p>对于微任务通常比宏任务优先级高，JS引擎会优先执行微任务，然后再执行宏任务。微任务的执行在当前宏任务执行后立即进行。</p><h2 id="29-const声明了数组，还能push元素吗？"><a href="#29-const声明了数组，还能push元素吗？" class="headerlink" title="29. const声明了数组，还能push元素吗？"></a>29. const声明了数组，还能push元素吗？</h2><p>可以。在 JavaScript 中，const 声明的变量不能被重新赋值，但它并不保证变量的值是不可变的。对于数组和对象这类引用类型，const 只是保证了变量指向的内存地址不能改变，但该地址所指向的数据内容是可以修改的。</p><h2 id="30-如何获取到一个实例对象的原型对象？"><a href="#30-如何获取到一个实例对象的原型对象？" class="headerlink" title="30. 如何获取到一个实例对象的原型对象？"></a>30. 如何获取到一个实例对象的原型对象？</h2><p>从构造函数获得原型对象：<code>构造函数.prototype</code><br>从对象实例获得父级原型对象：<code>对象实例.__proto__</code></p><h2 id="31-如何实现浏览器内多个标签页的通信？"><a href="#31-如何实现浏览器内多个标签页的通信？" class="headerlink" title="31. 如何实现浏览器内多个标签页的通信？"></a>31. 如何实现浏览器内多个标签页的通信？</h2><ul><li><p>BroadcastChannel，专为同源页面间通信设计的轻量级 API</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个频道（所有标签页使用相同名称）</span><br><span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BroadcastChannel</span>(<span class="hljs-string">&#x27;my-channel&#x27;</span>);<br><br><span class="hljs-comment">// 发送消息</span><br>channel.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Hello from tab A!&#x27;</span>);<br><br><span class="hljs-comment">// 接收消息</span><br>channel.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;收到消息:&#x27;</span>, event.<span class="hljs-property">data</span>);<br>&#125;;<br><br><span class="hljs-comment">// 可选：监听错误</span><br>channel.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;广播错误:&#x27;</span>, event);<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>localStorage 事件,当 localStorage 被修改时，同一源的其他标签页会触发 storage 事件（但不会通知当前修改的标签页）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在所有监听的标签页中：</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;storage&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br><span class="hljs-keyword">if</span> (event.<span class="hljs-property">key</span> === <span class="hljs-string">&#x27;tabMessage&#x27;</span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;来自其他标签页的消息:&#x27;</span>, event.<span class="hljs-property">newValue</span>);<br>&#125;<br>&#125;);<br><br><span class="hljs-comment">// 发送消息（在另一个标签页中执行）</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;tabMessage&#x27;</span>, <span class="hljs-string">&#x27;Hello from tab!&#x27;</span>);<br><span class="hljs-comment">// 可选：清除消息</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;tabMessage&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>SharedWorke,创建一个共享的 Worker 线程，多个页面可以连接到它进行通信。</p></li><li><p>服务器中转（WebSocket &#x2F; Server-Sent Events）<br>如果标签页都连接了同一个后端服务，可以通过服务器中转消息。</p></li></ul><h2 id="32-document-write-和innerHTML的区别？"><a href="#32-document-write-和innerHTML的区别？" class="headerlink" title="32. document.write()和innerHTML的区别？"></a>32. document.write()和innerHTML的区别？</h2><h3 id="document-write"><a href="#document-write" class="headerlink" title="document.write()"></a>document.write()</h3><ul><li>定义：是 document 对象的一个方法，用于向HTML 输出流中写入文本或 HTML。</li><li>如果在页面加载过程中调用：内容会插入到当前位置，相对安全。</li><li>如果在页面加载完成后调用（如点击事件、setTimeout）：会自动调用 document.open()，清空当前文档，重新写入内容，导致整个页面被覆盖！</li></ul><h3 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h3><ul><li>定义：是任意 DOM 元素的一个属性，表示该元素内部的 HTML 内容（作为字符串）</li><li>他将呢日哦那个写入某个DOM节点，不会导致页面重绘</li><li>在很多情况下都优于document.write(),其原因在于其允许更精确的控制要刷新页面的那一部分。</li></ul><h2 id="33-for…in和-for…of-有什么区别？"><a href="#33-for…in和-for…of-有什么区别？" class="headerlink" title="33. for…in和 for…of 有什么区别？"></a>33. for…in和 for…of 有什么区别？</h2><p>for…of 是ES6新增的，允许便利一个含有iterator接口的数据结构并返回各项的值，和for in的区别如下：</p><ul><li>for…of 遍历获取的是对象的键值，for…in获取的是对象的键名；</li><li>for…in 会遍历对象的整个原型链，不推荐使用，而for…of只遍历当前对象不会遍历原型链。</li><li>对于数组的遍历，for…in会返回数组中所有可枚举的属性，而for…of只返回数组下标对应的属性值；<br>总结：for…in循环主要为了遍历对象而生，不适用于遍历数组；for…of可以用来遍历数组、类数组对象，字符串、set、map一级Generator对象。</li></ul><h2 id="34-Object-defineProperty-和-ES6-的-Proxy-有什么区别？"><a href="#34-Object-defineProperty-和-ES6-的-Proxy-有什么区别？" class="headerlink" title="34. Object.defineProperty 和 ES6 的 Proxy 有什么区别？"></a>34. Object.defineProperty 和 ES6 的 Proxy 有什么区别？</h2><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>Object.defineProperty 是一个用于定义 或 修改 JavaScript对象属性的方法。它可以修改对象的属性描述符，包括属性值、可枚举性、可配置性和可写性。<br>语法：<code>Object.defineProperty(obj, prop, descriptor)</code>，其中，obj 是要定义或修改属性的对象，prop 是要定义或修改的属性名称，descriptor 是一个包含属性描述符的对象。 属性描述符对象 descriptor 中包含以下属性：</p><ul><li><p>value：属性值，可以是任意类型的值，包括基本数据类型、对象、函数等。如果不指定该属性，则默认为 undefined。</p></li><li><p>writable：属性是否可写，如果为 true，则属性的值可以被修改；如果为 false，则属性的值不能被修改。默认为 false。</p></li><li><p>enumerable：属性是否可枚举，如果为 true，则属性可以被 for…in 循环遍历到；如果为 false，则属性不能被遍历到。默认为 false。</p></li><li><p>configurable：是否可配置属性描述符，如果为 true，则属性描述符可以被修改；如果为 false，则属性描述符不能被修改。如果该属性为 false，则 writable 和 enumerable 的值也不能被修改。默认为 false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br><span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br><span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br><span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出 Tom</span><br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jerry&#x27;</span>; <span class="hljs-comment">// 不会修改属性值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出 Tom</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy 是 ES6 中新增的一个对象，它可以用来代理（拦截） JavaScript 中的对象操作，例如访问对象属性、调用函数、构造函数等。<br>语法：<code>new Proxy(target, handler)</code>，其中，target 是要代理的目标对象，handler 是一个对象，它包含了要代理的操作的处理函数（也称为拦截器）。<br>handler 对象中可以定义以下拦截器：</p><ul><li>get：拦截对象属性的读取操作，例如 obj.prop。</li><li>set：拦截对象属性的赋值操作，例如 obj.prop &#x3D; value。</li><li>apply：拦截函数的调用操作，例如 fn(args)。</li><li>construct：拦截类的构造函数的调用操作，例如 new MyClass(args)。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>二者之间的区别<br>  Object.defineProperty 和 ES6 的 Proxy 都是用于处理对象属性的工具，但它们的实现方式和用途略有不同。具体来说：</p><ul><li>Object.defineProperty 主要用于修改或扩展对象的属性描述符，它不能拦截对象的其他操作。</li><li>Proxy 可以拦截对象的各种操作，包括读取、赋值、删除、枚举等，它可以用于实现各种高级功能。</li><li>Object.defineProperty 是 ES5 中引入的，而 Proxy 是 ES6 中新增的。</li><li>Object.defineProperty 支持的操作比 Proxy 少，只能修改或扩展属性描述符，而 Proxy 支持的操作更加广泛。</li><li>在Vue2.x中，双向绑定是基于Object.defineProperty 实现的。而在Vue3.x中用的是proxy</li></ul><h2 id="35-ES6-的Reflect对象和-Proxy对象有什么区别？"><a href="#35-ES6-的Reflect对象和-Proxy对象有什么区别？" class="headerlink" title="35. ES6 的Reflect对象和 Proxy对象有什么区别？"></a>35. ES6 的Reflect对象和 Proxy对象有什么区别？</h2><p>Proxy 与 Reflect 是 ES6 为了操作对象引入的 API 。</p><p>Proxy 可以对目标对象的读取、函数调用等操作进行拦截，然后进行操作处理。它不直接操作对象，而是像代理模式，通过对象的代理对象进行操作，在进行这些操作时，可以添加一些需要的额外操作。</p><p>Reflect 可以用于获取目标对象的行为，它与 Object 类似，但是更易读，为操作对象提供了一种更优雅的方式。它的方法与 Proxy 是对应的。</p><h2 id="36-async-x2F-await-和-Promise-有什么关系？"><a href="#36-async-x2F-await-和-Promise-有什么关系？" class="headerlink" title="36. async&#x2F;await 和 Promise 有什么关系？"></a>36. async&#x2F;await 和 Promise 有什么关系？</h2><p>async&#x2F;await 是 ES7 引入的异步处理方案，它基于 Promise 实现。他们就是generator + promise 的语法糖,用同步的语句编写异步的代码，消灭异步回调。</p><ul><li>async 字面意思异步 async用于声明一个异步函数 <code>async function fn()&#123;...&#125;</code><br>在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</li><li>await 用于等待一个异步函数执行完成，并且语法规定，await只能在async函数里面被使用，如果需要用await等待一个async异步函数完成 ，需要在外面在包裹一层async。</li></ul><p>async&#x2F;await相辅相成，</p><ul><li>async函数返回的是promise实例对象</li><li>await后面可以跟promise函数</li><li>await相当于promise.then方法，并且只是成功的方法resolve,只是await时直接得到一个值，then需要传值进行回调</li><li>async await与Promise一样，是非阻塞的。</li><li>async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函数。</li></ul><h2 id="37-CSR和SSR-分别是什么？"><a href="#37-CSR和SSR-分别是什么？" class="headerlink" title="37. CSR和SSR 分别是什么？"></a>37. CSR和SSR 分别是什么？</h2><p>CSR 和 SSR 是前端开发中两种主要的页面渲染方式，它们决定了网页内容是在客户端（用户浏览器）还是在服务器端生成并发送给用户的。</p><h3 id="CSR（Client-Side-Rendering，客户端渲染）"><a href="#CSR（Client-Side-Rendering，客户端渲染）" class="headerlink" title="CSR（Client-Side Rendering，客户端渲染）"></a>CSR（Client-Side Rendering，客户端渲染）</h3><p><strong>核心思想</strong>：<br>服务器只返回一个空的 HTML 骨架（通常只有一个 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>）和一个 JavaScript 文件。<br>所有页面内容、数据获取、DOM 操作都由浏览器下载 JS 后，在客户端动态生成。<br><strong>工作流程</strong>：</p><ul><li>用户访问页面。</li><li>服务器返回一个极简的 HTML 文件（几乎为空）。</li><li>浏览器下载并执行 JavaScript 文件。</li><li>JS 代码向后端 API 请求数据。</li><li>JS 根据数据动态构建 DOM，最终显示完整页面。</li></ul><h3 id="SSR-Server-Side-Rendering-服务端渲染"><a href="#SSR-Server-Side-Rendering-服务端渲染" class="headerlink" title="SSR (Server-Side Rendering) - 服务端渲染"></a>SSR (Server-Side Rendering) - 服务端渲染</h3><p><strong>核心思想</strong>：</p><ul><li>服务器在接收到请求时，提前将页面内容渲染成完整的 HTML 字符串，然后直接发送给浏览器。</li><li>用户打开页面时，看到的是一个已经包含内容的完整页面。</li></ul><p><strong>工作流程</strong>：</p><ul><li>用户访问页面。</li><li>服务器接收到请求，调用后端逻辑或前端框架（在服务端运行）生成完整的 HTML。</li><li>服务器将包含数据的完整 HTML 发送给浏览器。</li><li>浏览器直接渲染出可视页面（首屏快）。</li><li>同时，JavaScript 也会被下载并“激活”（称为 Hydration），使页面具备交互能力。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端面试-CSS篇</title>
    <link href="/2025/08/26/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-css%E7%AF%87/"/>
    <url>/2025/08/26/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-css%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="1-让一个元素水平垂直居中的方案？"><a href="#1-让一个元素水平垂直居中的方案？" class="headerlink" title="1.让一个元素水平垂直居中的方案？"></a>1.让一个元素水平垂直居中的方案？</h2><p><img src="/2025/08/26/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-css%E7%AF%87/1-1.png" alt=" "></p><hr><h2 id="2-说说对盒子模型的理解？"><a href="#2-说说对盒子模型的理解？" class="headerlink" title="2.说说对盒子模型的理解？"></a>2.说说对盒子模型的理解？</h2><p><img src="/2025/08/26/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-css%E7%AF%87/2-1.png" alt=" "></p><p>一个盒子由四个部分组成：content、padding、border、margin</p><ol><li><p>标准盒模型：</p><ul><li>盒子总宽度 &#x3D; width + padding + border + margin;</li><li>盒子总高度 &#x3D; height + padding + border + margin</li></ul></li><li><p>IE怪异盒模型：</p><ul><li>盒子总宽度 &#x3D; width + margin;</li><li>盒子总高度 &#x3D; height + margin;</li></ul></li></ol><hr><h2 id="3-如何创建块级格式化上下文-block-formatting-context-BFC有什么用？"><a href="#3-如何创建块级格式化上下文-block-formatting-context-BFC有什么用？" class="headerlink" title="3.如何创建块级格式化上下文(block formatting context),BFC有什么用？"></a>3.如何创建块级格式化上下文(block formatting context),BFC有什么用？</h2><ol><li><p>创建规则：</p><ul><li>根元素</li><li>浮动元素（ float 不取值为 none ）</li><li>绝对定位元素（ position 取值为 absolute 或 fixed ）</li><li>display 取值为 inline-block 、 table-cell 、 table-caption 、 flex 、inline-flex 之⼀的元素</li><li>overflow 不取值为 visible 的元素</li></ul></li><li><p>作⽤：</p><ul><li>可以包含浮动元素</li><li>不被浮动元素覆盖</li><li>阻⽌父子元素的 margin 折叠</li></ul></li></ol><hr><h2 id="4-display有哪些值？说明他们的作用"><a href="#4-display有哪些值？说明他们的作用" class="headerlink" title="4.display有哪些值？说明他们的作用"></a>4.display有哪些值？说明他们的作用</h2><ul><li>block 转换成块状元素。</li><li>inline 转换成⾏内元素。</li><li>none 设置元素不可⻅。</li><li>inline-block 像⾏内元素⼀样显示，但其内容像块类型元素⼀样显示。</li><li>list-item 像块类型元素⼀样显示，并添加样式列表标记</li><li>table 此元素会作为块级表格来显示</li><li>inherit 规定应该从⽗元素继承 display 属性的值</li></ul><hr><h2 id="5-position的值，-relative和absolute定位原点是？"><a href="#5-position的值，-relative和absolute定位原点是？" class="headerlink" title="5. position的值， relative和absolute定位原点是？"></a>5. position的值， relative和absolute定位原点是？</h2><ul><li>absolute ：⽣成绝对定位的元素，相对于 static 定位以外的第⼀个⽗元素进⾏定位</li><li>fixed ：⽣成绝对定位的元素，相对于浏览器窗⼝进⾏定位</li><li>relative ：⽣成相对定位的元素，相对于其正常位置进⾏定位</li><li>static 默认值。没有定位，元素出现在正常的流中</li><li>inherit 规定从⽗元素继承 position 属性的值</li></ul><hr><h2 id="6-before-和-hover中双冒号和单冒号-有什么区别？解释一下这2个"><a href="#6-before-和-hover中双冒号和单冒号-有什么区别？解释一下这2个" class="headerlink" title="6. ::before 和 :hover中双冒号和单冒号 有什么区别？解释一下这2个"></a>6. ::before 和 :hover中双冒号和单冒号 有什么区别？解释一下这2个</h2><p>伪元素的作用<br>单冒号( : )用于 CSS3 伪类，双冒号( :: )用于 CSS3 伪元素<br>⽤于区分伪类和伪元素。</p><hr><h2 id="7-CSS不同选择器的权重-CSS层叠的规则"><a href="#7-CSS不同选择器的权重-CSS层叠的规则" class="headerlink" title="7.CSS不同选择器的权重(CSS层叠的规则)"></a>7.CSS不同选择器的权重(CSS层叠的规则)</h2><ul><li>! important 规则最重要，大于其它规则</li><li>行内样式规则，加 1000</li><li>对于选择器中给定的各个 ID 属性值，加 100</li><li>对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加 10</li><li>对于选择其中给定的各个元素标签选择器，加1</li><li>如果权值⼀样，则按照样式规则的先后顺序来应⽤，顺序靠后的覆盖靠前的规则</li></ul><hr><h2 id="8-CSS在性能优化方面的实践？"><a href="#8-CSS在性能优化方面的实践？" class="headerlink" title="8.CSS在性能优化方面的实践？"></a>8.CSS在性能优化方面的实践？</h2><ul><li>css 压缩与合并、 Gzip 压缩</li><li>css 文件放在 head 里、不要用 @import</li><li>尽量用缩写、避免用滤镜、合理使用选择器</li></ul><hr><h2 id="9-base64-的使用？"><a href="#9-base64-的使用？" class="headerlink" title="9.base64 的使用？"></a>9.base64 的使用？</h2><ul><li>⽤于减少 HTTP 请求</li><li>适⽤于⼩图⽚</li><li>base64 的体积约为原图的 4&#x2F;3</li></ul><hr><h2 id="10-水平居中的方法？"><a href="#10-水平居中的方法？" class="headerlink" title="10. 水平居中的方法？"></a>10. 水平居中的方法？</h2><ul><li>元素为⾏内元素，设置⽗元素 text-align:center</li><li>如果元素宽度固定，可以设置左右 margin 为 auto ;</li><li>如果元素为绝对定位，设置⽗元素 position 为 relative ，元素设left:0;right:0;margin:auto;</li><li>使用 flex-box 布局，指定 justify-content 属性为center<br>display 设置为 tabel-ceil</li></ul><hr><h2 id="11-垂直居中的方法？"><a href="#11-垂直居中的方法？" class="headerlink" title="11. 垂直居中的方法？"></a>11. 垂直居中的方法？</h2><ul><li>将显示方式设置为表格， display:table-cell ,同时设置 vertial-align：middle</li><li>使用 flex 布局，设置为 align-item：center</li><li>绝对定位中设置 bottom:0,top:0 ,并设置 margin:auto</li><li>绝对定位中固定高度时设置 top:50%，margin-top 值为⾼度⼀半的负值</li><li>文本垂直居中设置 line-height 为 height 值</li></ul><hr><h2 id="12-怎样做移动端的适配？"><a href="#12-怎样做移动端的适配？" class="headerlink" title="12. 怎样做移动端的适配？"></a>12. 怎样做移动端的适配？</h2><ol><li><p>响应式设计</p><ul><li>使用css媒体查询来根据设备特征应用不同样式</li><li>通过设置百分比宽度、最大宽度或相对单位来确保元素相对于其容器的大小进行自适应。</li></ul></li></ol><p>  <img src="/2025/08/26/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-css%E7%AF%87/12-1.png" alt=" "><br>2. 弹性布局和网格布局<br>3. 移动端优先，首先定义移动端的样式，然后使用媒体查询逐步添加到更大屏幕上，以确保基本功能在小屏幕上正常工作。</p><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端面试-HTML篇</title>
    <link href="/2025/08/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-HTML%E7%AF%87/"/>
    <url>/2025/08/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-HTML%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是DOM和BOM？"><a href="#1-什么是DOM和BOM？" class="headerlink" title="1. 什么是DOM和BOM？"></a>1. 什么是DOM和BOM？</h2><ol><li>DOM (Document Object Model):<ul><li>DOM是表示HTML和XML文档的标准的对象模型。它将文档中的每个组件都看作一个对象，可以用js操控DOM去动态改变 元素 结构 样式。</li><li>DOM 以树状结构组织文档的内容，其中树的根节点是 <code>document</code> 对象，代表整个文档。对象有各种方法和属性，可以用来访问和修改文档的内容和结构。</li></ul></li><li>BOM (Browser Object Model):<ul><li>BOM 是浏览器提供的对象模型，用于操作浏览器窗口。BOM 提供了与浏览器窗口交互的接口，如窗口大小、滚动位置、历史记录、cookie 等。</li></ul></li></ol><p>  DOM 是用于访问和操作网页文档的对象模型，而 BOM 是用于控制浏览器窗口及其各个组件的对象模型。<br>  在 JavaScript 编程中，开发者通常会同时使用 DOM 和 BOM 来完成各种任务，如操作网页元素、导航控制、事件处理等。</p><hr><h2 id="2-网址从输入到页面显示的全过程？"><a href="#2-网址从输入到页面显示的全过程？" class="headerlink" title="2. 网址从输入到页面显示的全过程？"></a>2. 网址从输入到页面显示的全过程？</h2><ul><li>DNS解析域名</li><li>发起TCP链接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析并渲染页面</li><li>链接结束</li></ul><hr><h2 id="3-浏览器解析渲染页面流程？"><a href="#3-浏览器解析渲染页面流程？" class="headerlink" title="3. 浏览器解析渲染页面流程？"></a>3. 浏览器解析渲染页面流程？</h2><p><img src="/2025/08/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-HTML%E7%AF%87/3-1.png" alt="浏览器解析渲染页面流程"></p><ul><li>解析HTML形成DOM树</li><li>解析CSS形成CSSOM树</li><li>加载JS，执行JS代码</li><li>合并DOM树和CSSOM树，形成Render Tree渲染树</li><li>计算元素位置进行页面布局</li><li>浏览器开始渲染并绘制页面</li></ul><hr><h2 id="4-行内元素有哪些？块级元素有哪些？空元素有哪些"><a href="#4-行内元素有哪些？块级元素有哪些？空元素有哪些" class="headerlink" title="4. 行内元素有哪些？块级元素有哪些？空元素有哪些"></a>4. 行内元素有哪些？块级元素有哪些？空元素有哪些</h2><p><img src="/2025/08/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-HTML%E7%AF%87/4-1.png" alt=" "></p><hr><h2 id="5-怎么实现点击回到顶部功能？"><a href="#5-怎么实现点击回到顶部功能？" class="headerlink" title="5. 怎么实现点击回到顶部功能？"></a>5. 怎么实现点击回到顶部功能？</h2><ol><li><p>锚点<br>在页面顶部放置一个指定名称的元素，比如 <code>&lt;a name=&quot;top&quot;&gt;&lt;/a&gt;</code>，之后在页面任意位置放置一个链接，比如 <code>&lt;a href=&quot;#top&quot;&gt;回到顶部&lt;/a&gt;</code>，点击链接即可回到顶部。</p></li><li><p>scrollTop()<br>scrollTop() 可以获取或设置元素内容从其顶部边缘滚动的像素数。<br>通过 <code>document.body.scrollTop=0</code> 或 <code>document.documentElement.scrollTop=0</code> 来实现回到顶部。</p></li><li><p>scrollTo()<br>scrollTo(0,0)方法可以使界面滚动到给定元素的指定坐标位置。</p><ul><li>方法一: element.scrollTo(x-coord, y-coord)<br><em>x-coord 是期望滚动到位置水平轴上距元素左上角的像素。<br>y-coord 是期望滚动到位置竖直轴上距元素左上角的像素。</em></li><li>方法二: element.scrollTo(options)<br><em>options是一个对象:<br>left (number类型)<br>top(number类型)<br>behavior: ‘smooth’ (平滑过渡效果)</em></li></ul></li><li><p>scrollBy()<br>scrollBy(xnum,ynum) 则是从当前位置滚动到某个相对位置，从当前位置起向右和向下滚动多少像素。<br>将当前位置的滚动长度作为参数，逆向滚动，传递给scrollBy()方法，即可实现回到顶部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> top = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span>;<br><span class="hljs-title function_">scrollBy</span>(<span class="hljs-number">0</span>,-top);<br></code></pre></td></tr></table></figure></li><li><p>scrollIntoView()</p><p><img src="/2025/08/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-HTML%E7%AF%87/5-1.png" alt=" "></p></li></ol><hr><h2 id="6-SEO相关？"><a href="#6-SEO相关？" class="headerlink" title="6. SEO相关？"></a>6. SEO相关？</h2><ol><li>SEO是什么？<br>SEO（Search Engine Optimization）搜索引擎优化，是为了从搜索引擎中获取流量，提高网站排名。</li><li>SEO原理<ul><li>爬行和抓取<br>爬虫抓取网页</li><li>索引<br>将抓取的网页解析存入数据库</li><li>搜索词处理<br>对用户的搜索关键词分词处理</li><li>排序<br>搜索引擎排序程序开始工作，对包含搜索词的网页按照评分进行排序</li></ul></li><li>SEO优化<br><img src="/2025/08/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-HTML%E7%AF%87/6-1.png" alt=" "></li></ol><hr><h2 id="7-label标签作用？"><a href="#7-label标签作用？" class="headerlink" title="7. label标签作用？"></a>7. label标签作用？</h2><p>label标签用于为表单元素提供标注，比如input标签，select标签，textarea标签。可以将label标签与input标签关联起来，这样点击label标签，就会触发input标签的点击事件。<br>给 <code>&lt;input&gt;</code>一个 id 属性。而 <code>&lt;label&gt;</code> 需要一个 for 属性，其值和 <code>&lt;input&gt;</code> 的 id 一样。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;cheese&quot;</span>&gt;</span>Do you like cheese?<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cheese&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cheese&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="8-CSSOM树和DOM树是同时解析的吗？"><a href="#8-CSSOM树和DOM树是同时解析的吗？" class="headerlink" title="8. CSSOM树和DOM树是同时解析的吗？"></a>8. CSSOM树和DOM树是同时解析的吗？</h2><p>CSSOM树和DOM树是同时解析的。浏览器会先解析HTML，将HTML解析成DOM树，然后解析CSS，将CSS解析成CSSOM树，解析CSS的过程不会阻塞，但如果遇到了JS脚本的时候CSSOM还没有构建完毕，则需等待CSSOM构建完毕后再去执行JS脚本，然后再执行DOM解析。最后将DOM树和CSSOM树合并，生成Render Tree。</p><hr><h2 id="9-HTML的生命周期？"><a href="#9-HTML的生命周期？" class="headerlink" title="9. HTML的生命周期？"></a>9. HTML的生命周期？</h2><ol><li>DOMContentLoaded —— 浏览器已完全加载 HTML，并构建了 DOM 树，当 DOM 准备就绪时，document 上的 DOMContentLoaded 事件就会被触发。在这个阶段，我们可以将 JavaScript 应用于元素。<br>诸如 <code>&lt;script&gt;</code>…<code>&lt;/script&gt;</code> 或 <code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code> 之类的脚本会阻塞 DOMContentLoaded，浏览器将等待它们执行结束。<br>图片和其他资源仍然可以继续被加载。<br>浏览器会在这里进行自动填充表单。</li><li>load —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。</li><li>beforeunload&#x2F;unload —— 当用户正在离开页面时。</li></ol><hr><h2 id="10-meta标签中的viewport属性有什么用？"><a href="#10-meta标签中的viewport属性有什么用？" class="headerlink" title="10. meta标签中的viewport属性有什么用？"></a>10. meta标签中的viewport属性有什么用？</h2><p>viewport 是一个元标签，用于定义网页的视口，即网页可见区域大小。<br>手机浏览器是把页面放在一个viewport中，然后缩放，达到一个最佳的显示效果。用户可以通过平移和缩放来浏览页面。<br>一个常用的针对移动网页优化的页面宽度设置是：<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code>。<br><img src="/2025/08/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-HTML%E7%AF%87/10-1.png" alt=" "></p><hr><h2 id="11-style写在body前后有什么区别？"><a href="#11-style写在body前后有什么区别？" class="headerlink" title="11.style写在body前后有什么区别？"></a>11.style写在body前后有什么区别？</h2><p>页面加载自上而下，style标签写在body之前，会优先加载，并应用到页面。而style标签写在body之后，当解析到写在尾部的样式表会导致浏览器停止之前的渲染，等到加载解析样式表后重新渲染，可能会出现页面闪烁问题。</p><hr><h2 id="12-如何进行网站的性能优化？"><a href="#12-如何进行网站的性能优化？" class="headerlink" title="12.如何进行网站的性能优化？"></a>12.如何进行网站的性能优化？</h2><ol><li>content 方面<ul><li>减少 HTTP 请求：合并文件、 CSS 精灵、 inline Image</li><li>减少 DNS 查询： DNS 缓存、将资源分布到恰当数量的主机名</li><li>减少 DOM 元素数量</li></ul></li><li>Server 方面<ul><li>使用 CDN</li><li>配置 ETag</li><li>对组件使用Gzip 压缩</li></ul></li><li>Cookie 方面<ul><li>减小 cookie 大小</li></ul></li><li>css 方面<ul><li>将样式表放到页面顶部</li><li>不使用 CSS 表达式</li><li>使用 <code>&lt;link&gt;</code> 不使用@import</li></ul></li><li>Javascript 方面<ul><li>将脚本放到页面底部</li><li>将 javascript 和 css 从外部引⼊</li><li>压缩 javascript 和 css</li><li>删除不需要的脚本</li></ul></li></ol><hr><h2 id="13-HTTP状态码及其含义"><a href="#13-HTTP状态码及其含义" class="headerlink" title="13.HTTP状态码及其含义"></a>13.HTTP状态码及其含义</h2><ol><li>1XX ：信息状态码<br>100 Continue 继续，⼀般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息</li><li>2XX ：成功状态码<br>200 OK 正常返回信息<br>201 Created 请求成功并且服务器创建了新的资源<br>202 Accepted 服务器已接受请求，但尚未处理</li><li>3XX ：重定向<br>301 Moved Permanently 请求的网页已永久移动到新位置。<br>302 Found 临时性重定向。<br>303 See Other 临时性重定向，且总是使⽤ GET 请求新的 URI 。<br>304 Not Modified ⾃从上次请求后，请求的⽹⻚未修改过。</li><li>4XX ：客户端错误<br>400 Bad Request 服务器⽆法理解请求的格式，客户端不应当尝试再次使⽤相同的内容发起请求。<br>401 Unauthorized 请求未授权。<br>403 Forbidden 禁⽌访问。<br>404 Not Found 找不到如何与 URI 相匹配的资源。</li><li>5XX: 服务器错误<br>500 Internal Server Error 最常见的服务器端错误。<br>503 Service Unavailable 服务器端暂时⽆法处理请求（可能是过载或维护</li></ol><hr><h2 id="14-请描述⼀下-cookies，sessionStorage和localStorage-的区别？"><a href="#14-请描述⼀下-cookies，sessionStorage和localStorage-的区别？" class="headerlink" title="14.请描述⼀下 cookies，sessionStorage和localStorage 的区别？"></a>14.请描述⼀下 cookies，sessionStorage和localStorage 的区别？</h2><ol><li>cookies:<br>cookies，它是网站为了标识用户身份而储存在用户本地终端上的数据。<br>cookies数据始终在同源的http请求中携带。会在浏览器和服务器间来回传递。<br>有设置的到期时间，到期之前一直有效。</li><li>sessionStorage:<br>用于临时保存同一窗口（或标签页）的数据，在关闭窗口或标签页之后将会删除这些数据。</li><li>localStorage:<br>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</li><li>存储大小：<br>cookies: 4K<br>sessionStorage&#x2F;localStorage: 5M</li></ol><hr><h2 id="15-在css-x2F-js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求⼀般情况下有哪些地方会有缓存处理？"><a href="#15-在css-x2F-js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求⼀般情况下有哪些地方会有缓存处理？" class="headerlink" title="15.在css&#x2F;js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求⼀般情况下有哪些地方会有缓存处理？"></a>15.在css&#x2F;js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求⼀般情况下有哪些地方会有缓存处理？</h2><p>dns 缓存， cdn 缓存，浏览器缓存，服务器缓存</p><hr><h2 id="16-行内元素和块内元素有什么区别？"><a href="#16-行内元素和块内元素有什么区别？" class="headerlink" title="16.行内元素和块内元素有什么区别？"></a>16.行内元素和块内元素有什么区别？</h2><p><img src="/2025/08/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-HTML%E7%AF%87/16-1.png" alt=" "></p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>前端面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Django】天天生鲜商城项目</title>
    <link href="/2023/04/04/daydayfresh/"/>
    <url>/2023/04/04/daydayfresh/</url>
    
    <content type="html"><![CDATA[<h3 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h3><ol><li>注册页(测试)<br>注册时校验用户名是否已被注册。<br>完成用户信息的注册。<br>给用户的注册邮箱发送邮件，用户点击邮件中的激活链接完成用户账户的激活。</li><li>登录页<br>实现用户的登录功能。</li><li>用户中心<br>用户中心信息页：显示登录用户的信息，包括用户名、电话和地址，同时页面下方显示出用户最近浏览的商品信息。<br>用户中心地址页：显示登录用户的默认收件地址，页面下方的表单可以新增用户的收货地址。<br>用户中心订单页：显示登录用户的订单信息。</li><li>其他<br>如果用户已经登录，页面顶部显示登录用户的信息</li></ol><h3 id="商品相关"><a href="#商品相关" class="headerlink" title="商品相关"></a>商品相关</h3><ol><li>首页<br>动态指定首页轮播商品信息。<br>动态指定首页活动信息。<br>动态获取商品的种类信息并显示。<br>动态指定首页显示的每个种类的商品(包括图片商品和文字商品)。<br>点击某一个商品时跳转到商品的详情页面。</li><li>商品详情页<br>显示出某个商品的详情信息。<br>页面的左下方显示出该种类商品的2个新品信息。</li><li>商品列表页<br>显示出某一个种类商品的列表数据，分页显示并支持按照默认、价格、和人气进行排序。<br>页面的左下方显示出该种类商品的2个新品信息。</li><li>其他<br>通过页面搜索框搜索商品信息。</li></ol><h3 id="购物车相关"><a href="#购物车相关" class="headerlink" title="购物车相关"></a>购物车相关</h3><p>列表页和详情页将商品添加到购物车。<br>用户登录后，首页，详情页，列表页显示登录用户购物车中商品的数目。<br>购物车页面：对用户购物车中商品的操作。如选择某件商品，增加或减少购物车中商品的数目。</p><h3 id="订单相关"><a href="#订单相关" class="headerlink" title="订单相关"></a>订单相关</h3><p>提交订单页面：显示用户准备购买的商品信息。<br>点击提交订单完成订单的创建。<br>用户中心订单页显示用户的订单信息。<br>点击支付完成订单的支付。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机考研复试】数据库系统概论</title>
    <link href="/2022/03/10/databaseinterview/"/>
    <url>/2022/03/10/databaseinterview/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库系统概论"><a href="#数据库系统概论" class="headerlink" title="数据库系统概论"></a>数据库系统概论</h1><hr><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论  "></a>第一章 绪论  </h2><h4 id="1-数据库是什么？"><a href="#1-数据库是什么？" class="headerlink" title="1.数据库是什么？"></a>1.数据库是什么？</h4><div class="code-wrapper"><pre><code class="hljs">数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。  </code></pre></div><h4 id="2-数据库管理系统是什么？"><a href="#2-数据库管理系统是什么？" class="headerlink" title="2.数据库管理系统是什么？"></a>2.数据库管理系统是什么？</h4><div class="code-wrapper"><pre><code class="hljs">数据库管理系统是位于用户应用与操作系统之间的一层数据管理软件；是基础软件。</code></pre></div><h4 id="3-数据库与数据库管理系统的区别和联系？"><a href="#3-数据库与数据库管理系统的区别和联系？" class="headerlink" title="3.数据库与数据库管理系统的区别和联系？"></a>3.数据库与数据库管理系统的区别和联系？</h4><div class="code-wrapper"><pre><code class="hljs">区别：数据库指的是一些数据的集合。数据库管理系统是位于操作系统和数据库应用系统之间的数据库管理软件。联系：数据库管理系统的存在使得数据库内的数据便于使用和维护。</code></pre></div><h4 id="4-数据库管理系统的主要功能？"><a href="#4-数据库管理系统的主要功能？" class="headerlink" title="4.数据库管理系统的主要功能？"></a>4.数据库管理系统的主要功能？</h4><div class="code-wrapper"><pre><code class="hljs">(1)数据定义功能(2)数据组织存储和管理(3)数据操纵(4)数据库的事务管理和运行管理(5)数据库的建立和维护。  </code></pre></div><h4 id="5-数据库系统是什么？"><a href="#5-数据库系统是什么？" class="headerlink" title="5.数据库系统是什么？"></a>5.数据库系统是什么？</h4><div class="code-wrapper"><pre><code class="hljs">数据库系统是由数据库、数据管理系统、应用程序和数据库管理员组成的存储、管理、处理、和维护数据的系统。</code></pre></div><h4 id="6-数据库系统的特点？"><a href="#6-数据库系统的特点？" class="headerlink" title="6.数据库系统的特点？"></a>6.数据库系统的特点？</h4><div class="code-wrapper"><pre><code class="hljs">(1)数据结构化(2)数据共享性高、冗余度低、易扩充(3)数据独立性高(4)数据由DBMS统一管理和控制。</code></pre></div><h4 id="7-数据库的三级模式？"><a href="#7-数据库的三级模式？" class="headerlink" title="7.数据库的三级模式？"></a>7.数据库的三级模式？</h4><div class="code-wrapper"><pre><code class="hljs">模式（逻辑模式）：是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。外模式（子模式）：是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图。内模式（存储模式）：一个数据库只有一个内模式，它是数据物理结构和存储方式的描述，是数据库内部的组织方式。 </code></pre></div><h4 id="8-什么是数据独立性？"><a href="#8-什么是数据独立性？" class="headerlink" title="8.什么是数据独立性？"></a>8.什么是数据独立性？</h4><div class="code-wrapper"><pre><code class="hljs">数据独立性是数据库系统的一个最重要的目标之一，它使数据能独立于应用程序。数据独立性包括数据的物理独立性和数据的逻辑独立性。</code></pre></div><h4 id="8-什么是物理独立性，逻辑独立性？"><a href="#8-什么是物理独立性，逻辑独立性？" class="headerlink" title="8.什么是物理独立性，逻辑独立性？"></a>8.什么是物理独立性，逻辑独立性？</h4><div class="code-wrapper"><pre><code class="hljs">(1)物理独立性：  用户的应用程序与数据库中的数据的物理存储是相互独立的。(2)逻辑独立性:用户的应用程序与数据库的逻辑结构是相互独立的。</code></pre></div><h4 id="9-数据库的两级映像以及如何保证物理、逻辑独立性？"><a href="#9-数据库的两级映像以及如何保证物理、逻辑独立性？" class="headerlink" title="9.数据库的两级映像以及如何保证物理、逻辑独立性？"></a>9.数据库的两级映像以及如何保证物理、逻辑独立性？</h4><div class="code-wrapper"><pre><code class="hljs">(1)外模式/模式映像：  当模式改变时，由数据库管理员对各个外模式/模式映像作相应改变，可以使外模式保持不变；应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性。  (2)模式/内模式映像：当数据库的存储结构改变时，数据库管理员修改模式/内模式映像，使模式保持不变，模式不变则应用程序不变，保证了数据与程序的物理独立性。  </code></pre></div><h4 id="10-DBA的职责是什么？"><a href="#10-DBA的职责是什么？" class="headerlink" title="10.DBA的职责是什么？"></a>10.DBA的职责是什么？</h4><div class="code-wrapper"><pre><code class="hljs">DBA负责全面管理和控制数据库系统的职责，具体有：(1)决定数据库中要存放哪些信息；(2)决定数据库的存储结构和存取策略；(3)定义数据的安全性要求和完整性约束条件；(4)监控数据库的使用和运行：转储数据、维护日志文件、故障恢复(5)数据库的改进和重组重构：对运行情况进行记录、统计分析，以此来不断改进数据库设计。</code></pre></div><h4 id="11-和文件系统相比-数据库文件有什么优点？"><a href="#11-和文件系统相比-数据库文件有什么优点？" class="headerlink" title="11.和文件系统相比,数据库文件有什么优点？"></a>11.和文件系统相比,数据库文件有什么优点？</h4><table><thead><tr><th>文件系统</th><th>数据库管理系统</th></tr></thead><tbody><tr><td>面向某一应用</td><td>面向现实世界</td></tr><tr><td>共享性差，冗余度大</td><td>共享性高，冗余度小</td></tr><tr><td>独立性差</td><td>具有较高的物理独立性和逻辑独立性</td></tr><tr><td>记录内有结构,整体无结构</td><td>整体结构化,用数据模型描述</td></tr><tr><td>应用程序自己控制</td><td>由数据库管理系统提供数据安全性,完整性,并发控制和恢复能力</td></tr></tbody></table><hr><hr><h2 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h2><h4 id="1-关系模型的三个组成部分？"><a href="#1-关系模型的三个组成部分？" class="headerlink" title="1.关系模型的三个组成部分？"></a>1.关系模型的三个组成部分？</h4><div class="code-wrapper"><pre><code class="hljs">关系模型由关系数据结构，关系操作集合和关系完整性约束组成。</code></pre></div><h4 id="2-关系模型的三类完整性约束？"><a href="#2-关系模型的三类完整性约束？" class="headerlink" title="2.关系模型的三类完整性约束？"></a>2.关系模型的三类完整性约束？</h4><div class="code-wrapper"><pre><code class="hljs">实体完整性，参照完整性，用户定义的完整性。</code></pre></div><h4 id="3-三类完整性约束的概念？"><a href="#3-三类完整性约束的概念？" class="headerlink" title="*3.三类完整性约束的概念？"></a>*3.三类完整性约束的概念？</h4><div class="code-wrapper"><pre><code class="hljs">实体完整性规则：若属性A是基本关系R的主属性，则A不能取空值。  参照完整性规则：若属性F是基本关系R的外码，它与基本关系S的主码K相对应，则对于R中每个元组在F上的值必须：或者取空值；或者等于S中某个元组的主码值。（外码要么为空，要么对应另一表的主码）</code></pre></div><h4 id="4-基本关系操作和专门关系运算和关系代数运算？"><a href="#4-基本关系操作和专门关系运算和关系代数运算？" class="headerlink" title="4.基本关系操作和专门关系运算和关系代数运算？"></a>4.基本关系操作和专门关系运算和关系代数运算？</h4><div class="code-wrapper"><pre><code class="hljs">基本关系操作：选择、投影、并、差、笛卡尔积。专门关系运算：选择、投影、连接、除运算。基本关系代数运算：并、差、笛卡尔积、投影、选择。</code></pre></div><h4 id="5-解释候选码和主码的关系？"><a href="#5-解释候选码和主码的关系？" class="headerlink" title="5.解释候选码和主码的关系？"></a>5.解释候选码和主码的关系？</h4><div class="code-wrapper"><pre><code class="hljs">若关系中的某一属性组的值能唯一标识一个元组，该属性组称为候选码；如果一个关系有多个候选码，其中一个被选为主码。候选码可以有多个，而主码只能有一个。</code></pre></div><h4 id="6-等值连接与自然连接的区别和联系？"><a href="#6-等值连接与自然连接的区别和联系？" class="headerlink" title="*6.等值连接与自然连接的区别和联系？"></a>*6.等值连接与自然连接的区别和联系？</h4><div class="code-wrapper"><pre><code class="hljs">自然连接是等值连接的一种特殊情况；等值连接要求连接的是值相等的分量，两个关系中可以没有相同的属性；进行自然连接的两个关系中必须有相同的属性。等值连接不要求去掉重复属性列；自然连接时需要除掉重复的属性列。</code></pre></div><h4 id="7-外连接是什么？"><a href="#7-外连接是什么？" class="headerlink" title="*7.外连接是什么？"></a>*7.外连接是什么？</h4><div class="code-wrapper"><pre><code class="hljs">外连接是指两个表在进行操作时，不仅返回符合连接和查询条件的元组，还返回不符合条件的一些元组；左外连接是指返回左表中仅符合连接条件不符合查询条件的元组；右外连接是指返回右表中仅符合连接条件不符合查询条件的元组；全外连接是左外连接和右外连接去掉重复项的元组集并集。</code></pre></div><hr><hr><h2 id="第三章-SQL"><a href="#第三章-SQL" class="headerlink" title="第三章 SQL"></a>第三章 SQL</h2><h4 id="1-SQL的特点？"><a href="#1-SQL的特点？" class="headerlink" title="1.SQL的特点？"></a>1.SQL的特点？</h4><div class="code-wrapper"><pre><code class="hljs">结构化查询语言（Structured Query Language）综合统一、高度非过程化、面向集合的操作方式、以同一种语法结构提供多种使用方式、语言简洁易学易用。</code></pre></div><h4 id="2-什么是基本表？什么是视图？两者的区别和联系是什么？"><a href="#2-什么是基本表？什么是视图？两者的区别和联系是什么？" class="headerlink" title="2.什么是基本表？什么是视图？两者的区别和联系是什么？"></a>2.什么是基本表？什么是视图？两者的区别和联系是什么？</h4><div class="code-wrapper"><pre><code class="hljs">基本表是本身独立存在的表，在SQL中一个关系就对应一个表。视图是从一个或几个基本表导出的表，本身不独立存储在数据库中，是虚表。即数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍存放在导出视图的基本表中。视图在概念上与基本表等同，用户可以如基本表那样使用视图，可以在视图上再定义视图。</code></pre></div><h4 id="3-视图的优点和作用？"><a href="#3-视图的优点和作用？" class="headerlink" title="3.视图的优点和作用？"></a>3.视图的优点和作用？</h4><div class="code-wrapper"><pre><code class="hljs">(1)简化用户操作(2)视图使用户能够以多种角度看待同一数据(3)视图对重构数据库提供了一定程度的逻辑独立性(4)视图能够对机密数据提供安全保护(5)利用视图可以更清晰表达查询。</code></pre></div><h4 id="4-哪类视图可以更新？哪类视图是不可更新的？"><a href="#4-哪类视图可以更新？哪类视图是不可更新的？" class="headerlink" title="4.哪类视图可以更新？哪类视图是不可更新的？"></a>4.哪类视图可以更新？哪类视图是不可更新的？</h4><div class="code-wrapper"><pre><code class="hljs">基本表的行列子集视图一般可更新。若视图的属性来自集合函数、表达式，则该视图肯定是不可以更新的。对视图的更新最终要转化为对基本表的更新。</code></pre></div><h4 id="5-索引的作用？和它的优点缺点是什么？"><a href="#5-索引的作用？和它的优点缺点是什么？" class="headerlink" title="*5.索引的作用？和它的优点缺点是什么？"></a>*5.索引的作用？和它的优点缺点是什么？</h4><div class="code-wrapper"><pre><code class="hljs">当表的数据量比较大时，查询操作比较耗时，建立索引可以加快查询速度。优点：加速查询速度；缺点：索引需要占一定的存储空间，且基本表更新时需要维护索引表。</code></pre></div><h4 id="6-索引和键有什么区别？"><a href="#6-索引和键有什么区别？" class="headerlink" title="6.索引和键有什么区别？"></a>6.索引和键有什么区别？</h4><div class="code-wrapper"><pre><code class="hljs">索引是存储在数据库中的一个物理结构，是实际存在的，相当于一本书的目录；键是一个逻辑概念，不是数据库中的物理部分。键分为主键和外键，主键相当于一本书中每个页的页码。</code></pre></div><h4 id="7-什么是数据库操纵语言、什么是数据库控制语言-试举例说明"><a href="#7-什么是数据库操纵语言、什么是数据库控制语言-试举例说明" class="headerlink" title="7.什么是数据库操纵语言、什么是数据库控制语言,试举例说明"></a>7.什么是数据库操纵语言、什么是数据库控制语言,试举例说明</h4><div class="code-wrapper"><pre><code class="hljs">数据操纵语言是指通过对表中的数据进行插入、删除和修改等操作，实现对数据库的基本操作。如：SELECT命令的作用是检查表的内容，UPDATE命令的作用是修改表等等。数据控制语言是用来设置或者更改数据库用户或角色权限的语句，这些语句包括GRANT、REVOKE等语句。</code></pre></div><h4 id="8-数据库中常用的索引有哪些？"><a href="#8-数据库中常用的索引有哪些？" class="headerlink" title="8.数据库中常用的索引有哪些？"></a>8.数据库中常用的索引有哪些？</h4><div class="code-wrapper"><pre><code class="hljs">B+树索引：B+树是对B树优化处理了的多路搜索树，与B树的区别在于，B树的每个结点都可以存储数据，而B+树只有叶子结点可以存储数据，且每个叶子结点都用链表链接。在数据库的查询中一般都是批量查询数据，采用B+树一次查询多条时，确定首尾位置，便可以方便的确定多条数据位置，提高查询效率。Hash索引：通过一定的算法计算出哈希值，然后映射出对应的数据存储位置。检索速度快，但是哈希值可能存在碰撞。</code></pre></div><hr><hr><h2 id="第四章-数据库安全性"><a href="#第四章-数据库安全性" class="headerlink" title="第四章 数据库安全性"></a>第四章 数据库安全性</h2><h4 id="1-什么时数据库的安全性？"><a href="#1-什么时数据库的安全性？" class="headerlink" title="1.什么时数据库的安全性？"></a>1.什么时数据库的安全性？</h4><div class="code-wrapper"><pre><code class="hljs">指保护数据库以防止不合法的使用造成数据泄露、更改或破坏。</code></pre></div><h4 id="2-对数据库安全性产生威胁的因素？"><a href="#2-对数据库安全性产生威胁的因素？" class="headerlink" title="2.对数据库安全性产生威胁的因素？"></a>2.对数据库安全性产生威胁的因素？</h4><div class="code-wrapper"><pre><code class="hljs">（1）非授权用户恶意存储和破坏（2）数据库中敏感或者重要的数据泄露（3）安全环境的脆弱性</code></pre></div><h4 id="3-实现数据库安全性控制的常用方法和技术？"><a href="#3-实现数据库安全性控制的常用方法和技术？" class="headerlink" title="3.实现数据库安全性控制的常用方法和技术？"></a>3.实现数据库安全性控制的常用方法和技术？</h4><div class="code-wrapper"><pre><code class="hljs">（1）用户身份鉴别（2）存取控制：通过用户权限定义和合法性检查确保只有合法权限的用户访问数据库（3）视图机制：为不同用户定义视图，通过视图机制把要保密的数据对无权存取的用户隐藏起来。（4）审计：把用户对数据库的所有操作自动记录下来放到审计日志中，DBA用审计追踪信息，重现导致现有状况的一系列操作，找出非法存取数据的人，时间，内容。（5）数据加密：对存储和传输的数据进行加密处理</code></pre></div><h4 id="4-什么是自主存取控制方法和强制存取控制方法？"><a href="#4-什么是自主存取控制方法和强制存取控制方法？" class="headerlink" title="4.什么是自主存取控制方法和强制存取控制方法？"></a>4.什么是自主存取控制方法和强制存取控制方法？</h4><div class="code-wrapper"><pre><code class="hljs">（1）自主存取控制：定义各个用户对不同数据对象的存取权限，当用户对数据库访问时实现检查用户的存取权限。防止不合法用户对数据库的存取。（2）强制存取控制方法：每个数据对象被标以一定的密级，每一级用户也被授予一个级别的许可证。系统规定具有某一许可证级别的用户才能存取某一密级的数据对象。</code></pre></div><h4 id="5-什么是数据库角色？"><a href="#5-什么是数据库角色？" class="headerlink" title="5.什么是数据库角色？"></a>5.什么是数据库角色？</h4><div class="code-wrapper"><pre><code class="hljs">数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合，可以为一组具有相同权限的用户创建一个角色，简化授权过程。</code></pre></div><h4 id="6-数据加密的思想和方式？"><a href="#6-数据加密的思想和方式？" class="headerlink" title="6.数据加密的思想和方式？"></a>6.数据加密的思想和方式？</h4><div class="code-wrapper"><pre><code class="hljs">加密的基本思想是根据一定算法将原始数据--明文变换为不可直接识别的格式--密文，从而使的不知道解密算法的人无法获知数据数据加密主要包括存储加密和传输加密。</code></pre></div><h4 id="7-数据冗余的影响"><a href="#7-数据冗余的影响" class="headerlink" title="*7.数据冗余的影响"></a>*7.数据冗余的影响</h4><div class="code-wrapper"><pre><code class="hljs">1、存储空间的浪费。2、数据交互和数据库访问执行效率降低。</code></pre></div><hr><hr><h2 id="第五章-数据库完整性"><a href="#第五章-数据库完整性" class="headerlink" title="第五章 数据库完整性"></a>第五章 数据库完整性</h2><h4 id="1-什么是数据库完整性？"><a href="#1-什么是数据库完整性？" class="headerlink" title="1.什么是数据库完整性？"></a>1.什么是数据库完整性？</h4><div class="code-wrapper"><pre><code class="hljs">数据库完整性是指数据的正确性和相容性。</code></pre></div><h4 id="2-数据库完整性与安全性的区别？"><a href="#2-数据库完整性与安全性的区别？" class="headerlink" title="2.数据库完整性与安全性的区别？"></a>2.数据库完整性与安全性的区别？</h4><div class="code-wrapper"><pre><code class="hljs">数据的完整性是为了防止数据库中存在不合语义的数据，防止错误信息的输入输出。数据的安全性是保护数据库防止恶意破坏和非法存取。因此，完整性措施的防范对象是不合语义的数据，安全性措施防范的对象是非法用户和非法操作。</code></pre></div><h4 id="3-什么是数据库的完整性约束条件？"><a href="#3-什么是数据库的完整性约束条件？" class="headerlink" title="3.什么是数据库的完整性约束条件？"></a>3.什么是数据库的完整性约束条件？</h4><div class="code-wrapper"><pre><code class="hljs">完整性约束条件是指数据库中的数据应该满足的语义约束条件。</code></pre></div><h4 id="4-关系数据库管理系统为维护数据库的完整性必须有什么功能？"><a href="#4-关系数据库管理系统为维护数据库的完整性必须有什么功能？" class="headerlink" title="4.关系数据库管理系统为维护数据库的完整性必须有什么功能？"></a>4.关系数据库管理系统为维护数据库的完整性必须有什么功能？</h4><div class="code-wrapper"><pre><code class="hljs">（1）定义功能：提供定义完整性约束条件的机制。（2）检查功能：检查用户发出的操作请求是否违背了完整性约束条件。（3）违约处理：若发现用户的操作请求使数据违背了完整性约束条件，则采取一定动作来保证数据完整性。</code></pre></div><h4 id="5-实体完整性检查和违约处理？"><a href="#5-实体完整性检查和违约处理？" class="headerlink" title="5.实体完整性检查和违约处理？"></a>5.实体完整性检查和违约处理？</h4><div class="code-wrapper"><pre><code class="hljs">检查主码值是否唯一，如果不唯一则拒绝插入和修改。检查主码的各个属性是否为空，只要有一个为空就拒绝插入和修改。</code></pre></div><h4 id="6-参照完整性检查和违约处理？"><a href="#6-参照完整性检查和违约处理？" class="headerlink" title="6.参照完整性检查和违约处理？"></a>6.参照完整性检查和违约处理？</h4><table><thead><tr><th>被参照表（如student）</th><th>参照表（如SC）</th><th>违约处理</th></tr></thead><tbody><tr><td>可能破坏参照完整性</td><td>插入元组</td><td>拒绝</td></tr><tr><td>可能破坏参照完整性</td><td>修改外码值</td><td>拒绝</td></tr><tr><td>删除元组</td><td>可能破坏参照完整性</td><td>拒绝&#x2F;级联删除&#x2F;设置为空值</td></tr><tr><td>修改主码值</td><td>可能破坏参照完整性</td><td>拒绝&#x2F;级联删除&#x2F;设置为空值</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs">级联（CASCADE）操作:当删除或修改被参照表的一个元组导致与参照表不一致时，删除或修改参照表中的所有导致不一致的元组。</code></pre></div><h4 id="7-断言（assertion）"><a href="#7-断言（assertion）" class="headerlink" title="7.断言（assertion）"></a>7.断言（assertion）</h4><div class="code-wrapper"><pre><code class="hljs">通过声明性断言来指定更具一般性的约束。断言创建以后，任何对断言中所涉及关系的操作都会出发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行。</code></pre></div><h4 id="8-触发器（trigger）（事件-条件-动作规则）"><a href="#8-触发器（trigger）（事件-条件-动作规则）" class="headerlink" title="*8.触发器（trigger）（事件-条件-动作规则）"></a>*8.触发器（trigger）（事件-条件-动作规则）</h4><div class="code-wrapper"><pre><code class="hljs">触发器是用户定义在关系表上的一类由事件驱动的特殊过程。当特定的系统事件发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行。</code></pre></div><h4 id="9-触发器的作用？"><a href="#9-触发器的作用？" class="headerlink" title="9.触发器的作用？"></a>9.触发器的作用？</h4><div class="code-wrapper"><pre><code class="hljs">触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该表的操作又会导致该表的触发器被触发。</code></pre></div><hr><hr><h2 id="第六章-关系数据理论"><a href="#第六章-关系数据理论" class="headerlink" title="第六章 关系数据理论"></a>第六章 关系数据理论</h2><h4 id="1-数据依赖？"><a href="#1-数据依赖？" class="headerlink" title="1.数据依赖？"></a>1.数据依赖？</h4><div class="code-wrapper"><pre><code class="hljs">数据依赖是一个关系内部属性与属性之间的一种约束关系。</code></pre></div><h4 id="2-函数依赖（非平凡、平凡、完全、部分、传递）？"><a href="#2-函数依赖（非平凡、平凡、完全、部分、传递）？" class="headerlink" title="2.函数依赖（非平凡、平凡、完全、部分、传递）？"></a>2.函数依赖（非平凡、平凡、完全、部分、传递）？</h4><div class="code-wrapper"><pre><code class="hljs">设R(U)是属性集U上的关系模式，X,Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称X函数确定Y或Y函数依赖于X，记作X-&gt;Y。非平凡函数依赖：诸如（学号，课程号）-&gt;成绩  平凡函数依赖：诸如（学号，课程号）-&gt;学号  完全函数依赖：诸如（学号，课程号）-&gt;成绩  部分函数依赖：诸如（学号，课程号）-&gt;部门 ，因为（学号）-&gt;部门 成立。  传递函数依赖：诸如（学号）-&gt;部门，（部门）-&gt;系名 得（学号）-&gt;系名</code></pre></div><h4 id="3-候选码、超码、主码、外码、全码？"><a href="#3-候选码、超码、主码、外码、全码？" class="headerlink" title="3.候选码、超码、主码、外码、全码？"></a>3.候选码、超码、主码、外码、全码？</h4><div class="code-wrapper"><pre><code class="hljs">(1)候选码：若U完全函数依赖于K，则K为候选码，如成绩完全依赖学号课程号，则这俩为候选码。(2)主码：若候选码多于一个，则选定其中一个为主码。(3)超码：若U函数依赖于K，则K成为超码。(4)全码：整个属性组是码。(5)主属性：包含在任何一个候选码中得属性称为主属性。反之非主属性。(6)外码：关系模式R中属性或属性组X并非R的码，但X是另一个关系模式得码，则称X是R的外部码。</code></pre></div><h4 id="4-什么是规范化？"><a href="#4-什么是规范化？" class="headerlink" title="4.什么是规范化？"></a>4.什么是规范化？</h4><div class="code-wrapper"><pre><code class="hljs">一个低一级范式的关系模式通过 模式分解 可以转换为若干个高一级范式的关系模式的集合，这个过程就叫规范化。</code></pre></div><h4 id="5-范式"><a href="#5-范式" class="headerlink" title="*5.范式"></a>*5.范式</h4><div class="code-wrapper"><pre><code class="hljs">(1)第一范式：如果一个关系模式R的所有属性都是不可分的基本数据项，则R属于第一范式。(2)第二范式：若R属于第一范式，且每一个 非主属性 完全函数依赖 与 任何 一个候选码，则R属于第二范式。*(3)第三范式：设关系模式R属于第一范式，若R中 不存在 这样的码X，属性组Y及非主属性Z使得X-&gt;Y，Y-&gt;Z成立，Y不确定X，则称R属于第三范式。（直观来讲，保证每个非主属性既不传递依赖于码，也不部分依赖于码。确保数据表中每一列数据和主码直接相关，而不能间接相关）(4)BC范式：关系模式R属于第一范式，若X-&gt;Y且Y不含于X时必含有码，则R属于BCNF也就是说：关系模式R中，若每一个决定因素都包含码，则R属于BCNF。(5)第四范式：限制关系模式的属性之间不允许由非平凡且非函数依赖的多值依赖。</code></pre></div><h4 id="6-多值依赖"><a href="#6-多值依赖" class="headerlink" title="6.多值依赖"></a>6.多值依赖</h4><div class="code-wrapper"><pre><code class="hljs">设R(U)是属性集U上的一个关系模式，X,Y和Z是U的子集，并且Z=U-X-Y，在R(U)的任一关系r中，如果存在元组(X1,Y1,Z1)和(X1,Y2,Z2)，则必存在(X1,Y2,Z1)和(X1,Y1,Z2),即交换两个元组的Y值所得两个新元组必在r中，那么称Y多值依赖于X，记作X-&gt;-&gt;Y。若X-&gt;-&gt;Y，且Z为空集，则称X-&gt;-&gt;Y为平凡多值依赖若X-&gt;-&gt;Y，且Z不是空集，则称X-&gt;-&gt;Y为非平凡多值依赖</code></pre></div><h4 id="7-多值依赖于函数依赖的区别？"><a href="#7-多值依赖于函数依赖的区别？" class="headerlink" title="7.多值依赖于函数依赖的区别？"></a>7.多值依赖于函数依赖的区别？</h4><div class="code-wrapper"><pre><code class="hljs">(1)多值依赖的有效性与属性集的范围有关(2)函数依赖规定某些元组不能出现在关系中；多值依赖要求某种形式的其它元组必须在关系中。</code></pre></div><h4 id="8-范式之间的转换流程？"><a href="#8-范式之间的转换流程？" class="headerlink" title="*8.范式之间的转换流程？"></a>*8.范式之间的转换流程？</h4><pre><code class=" mermaid">graph TDA[1NF] --&gt;|消除非主属性对码的部分函数依赖| B[2NF]    B --&gt; |消除非主属性对码的传递函数依赖| C[3NF]    C --&gt; |消除主属性对码的部分和传递依赖| D[BCNF]    D --&gt; |消除非平凡且非函数依赖的多值依赖| E[4NF]    F&#123;规范化过程&#125;</code></pre><hr><hr><h2 id="第七章-数据库设计"><a href="#第七章-数据库设计" class="headerlink" title="第七章 数据库设计"></a>第七章 数据库设计</h2><h4 id="1-数据库设计的基本步骤？"><a href="#1-数据库设计的基本步骤？" class="headerlink" title="*1.数据库设计的基本步骤？"></a>*1.数据库设计的基本步骤？</h4><div class="code-wrapper"><pre><code class="hljs">(1)需求分析。了解和分析用户需求；(2)概念结构设计。对用户需求进行抽象和归纳，形成一个独立于DBMS的概念模型（E-R图）；(3)逻辑结构设计。将概念结构转换为数据模型，通常为关系模型；(4)物理结构设计。为逻辑数据模型选取一个最适合存储结构和存取方法；(5)数据库实施阶段。编写数据库，编写和调试应用程序；(6)数据库运行和维护。正式投入运行。</code></pre></div><h4 id="2-数据字典是什么？有什么作用？"><a href="#2-数据字典是什么？有什么作用？" class="headerlink" title="2.数据字典是什么？有什么作用？"></a>2.数据字典是什么？有什么作用？</h4><div class="code-wrapper"><pre><code class="hljs">内容：数据项，数据结构，数据流，数据存储和处理过程作用：数据字典是关于数据库中数据的描述，在需求分析阶段建立，是下一步进行概念设计的基础，并在数据库设计过程中不断处理充实和完善。</code></pre></div><h4 id="3-概念模型有什么作用？"><a href="#3-概念模型有什么作用？" class="headerlink" title="3.概念模型有什么作用？"></a>3.概念模型有什么作用？</h4><div class="code-wrapper"><pre><code class="hljs">概念模型用于信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员进行数据库设计的有力工具，也是数据库设计人员和用户之间进行交流的语言。</code></pre></div><h4 id="4-ER图构造过程？"><a href="#4-ER图构造过程？" class="headerlink" title="4. ER图构造过程？"></a>4. ER图构造过程？</h4><div class="code-wrapper"><pre><code class="hljs">实体型用矩形表示，矩形框内写明实体名属性用椭圆形表示，并用无向边将其与相应的实体型链接起来联系用菱形表示，菱形框内写联系名，并用无向边分别于有关实体型链接起来，同时在无向边旁边表上联系的类型（1：1，1：n，m：n）</code></pre></div><h4 id="5-合并E-R图时主要包括哪几种冲突？"><a href="#5-合并E-R图时主要包括哪几种冲突？" class="headerlink" title="5.合并E-R图时主要包括哪几种冲突？"></a>5.合并E-R图时主要包括哪几种冲突？</h4><div class="code-wrapper"><pre><code class="hljs">属性冲突。不同的实体对同一属性的定义不同；命名冲突。同名异义、异名同义；结构冲突。同一实体在不同的局部E-R图中有不同的抽象。</code></pre></div><h4 id="6-一个实体型转换为一个关系模式有哪几种情况？（将ER图转换为关系模式时，可以如何处理实体型间的联系？）"><a href="#6-一个实体型转换为一个关系模式有哪几种情况？（将ER图转换为关系模式时，可以如何处理实体型间的联系？）" class="headerlink" title="6.一个实体型转换为一个关系模式有哪几种情况？（将ER图转换为关系模式时，可以如何处理实体型间的联系？）"></a>6.一个实体型转换为一个关系模式有哪几种情况？（将ER图转换为关系模式时，可以如何处理实体型间的联系？）</h4><div class="code-wrapper"><pre><code class="hljs">一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并；一个1：n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并；一个m：n联系可以转换为一个关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性。</code></pre></div><h4 id="7-什么是数据库的再组织，再构造？为什么要进行数据库的再组织，再构造？"><a href="#7-什么是数据库的再组织，再构造？为什么要进行数据库的再组织，再构造？" class="headerlink" title="7.什么是数据库的再组织，再构造？为什么要进行数据库的再组织，再构造？"></a>7.什么是数据库的再组织，再构造？为什么要进行数据库的再组织，再构造？</h4><div class="code-wrapper"><pre><code class="hljs">再组织 是指按原先设计要求重新安排存储位置，回收垃圾，减少指针链提高系统性能。再构造 是指部分修改数据库的模式和内模式，即修改原设计的逻辑和物理结构。原因：(1)由于记录的不断增删改查使DB的物理存储情况变差，存取效率降低，性能下降，需重组织。(2)数据库应用环境常常发生变化，实体之间的联系发生变化，使原有的数据库设计不能满足新的需求，需调整数据库的模式和内模式。</code></pre></div><hr><hr><h2 id="第八章-数据库编程"><a href="#第八章-数据库编程" class="headerlink" title="第八章 数据库编程"></a>第八章 数据库编程</h2><h4 id="1-什么是游标，为什么引入游标？"><a href="#1-什么是游标，为什么引入游标？" class="headerlink" title="*1.什么是游标，为什么引入游标？"></a>*1.什么是游标，为什么引入游标？</h4><div class="code-wrapper"><pre><code class="hljs">游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果。(1)SQL语言与诸语言具有不同的数据处理方式。(2)SQL语言是面向集合的，一条SQL语句原则上可以产生或处理多条记录。(3)主语言是面向记录的，一组著变量一次只能存放一条记录。(4)仅使用主变量并不能完全满足SQL语句想应用程序输出数据的要求。(5)嵌入式SQL引入了游标的概念用来协调这两种不同的处理方式。</code></pre></div><h4 id="2-描述数据库对嵌入式SQL的处理过程？"><a href="#2-描述数据库对嵌入式SQL的处理过程？" class="headerlink" title="2.描述数据库对嵌入式SQL的处理过程？"></a>2.描述数据库对嵌入式SQL的处理过程？</h4><div class="code-wrapper"><pre><code class="hljs">DBMS的预处理程序对源程序进行扫描，识别出嵌入式SQL语句，把他们转换成主语言调用语句，使得主语言编译程序可以识别它们，然后将它们编译成目标代码。</code></pre></div><h4 id="3-什么是存储过程？用什么来调用？"><a href="#3-什么是存储过程？用什么来调用？" class="headerlink" title="3.什么是存储过程？用什么来调用？"></a>3.什么是存储过程？用什么来调用？</h4><div class="code-wrapper"><pre><code class="hljs">存储过程是个预编译的SQL语句集合，优点是可以建立非常复杂的查询，只需创建一次，在程序中即可多次调用，且比执行单纯的SQL语句要快。可以创建一个命令对象进行调用。   </code></pre></div><h4 id="4-ODBC"><a href="#4-ODBC" class="headerlink" title="4.ODBC?"></a>4.ODBC?</h4><div class="code-wrapper"><pre><code class="hljs">ODBC是微软公司开放服务体系中有关数据库的一个组成部分，它建立了一组规范，并提供一组访问数据库的应用程序编程接口。</code></pre></div><hr><hr><h2 id="第九章-关系查询处理和查询优化"><a href="#第九章-关系查询处理和查询优化" class="headerlink" title="第九章 关系查询处理和查询优化"></a>第九章 关系查询处理和查询优化</h2><h4 id="1-关系数据库中查询处理的步骤是什么？每一步进行简要概括"><a href="#1-关系数据库中查询处理的步骤是什么？每一步进行简要概括" class="headerlink" title="1.关系数据库中查询处理的步骤是什么？每一步进行简要概括"></a>1.关系数据库中查询处理的步骤是什么？每一步进行简要概括</h4><div class="code-wrapper"><pre><code class="hljs">(1)查询分析：对查询语句进行词法分析、语法分析（检查其是否正确）；(2)查询检查：对合法的查询语句进行语义检查（语义检查就是检查其是否存有效）(3)查询优化：选择一个高效执行的查询处理策略；(4)查询执行：依据优化得到的执行策略生成查询执行计划，并生成相应的查询执行计划代码。</code></pre></div><h4 id="2-查询优化？"><a href="#2-查询优化？" class="headerlink" title="2.查询优化？"></a>2.查询优化？</h4><div class="code-wrapper"><pre><code class="hljs">查询优化分为 代数优化和物理优化。代数优化：通过对关系代数表达式的等价变换来提高查询效率。物理优化：选择高效合理的操作算法或存取路径，求得优化的查询计划，达到查询优化的目标。</code></pre></div><h4 id="3-启发式优化规则的代数优化包括哪几点？"><a href="#3-启发式优化规则的代数优化包括哪几点？" class="headerlink" title="3.启发式优化规则的代数优化包括哪几点？"></a>3.启发式优化规则的代数优化包括哪几点？</h4><div class="code-wrapper"><pre><code class="hljs">选择运算尽可能先做；投影操作和选择运算同时进行；把笛卡尔积和附近的一连串选择和投影操作合并起来做。找出公共子表达式。</code></pre></div><hr><hr><h2 id="第十章-数据库恢复技术"><a href="#第十章-数据库恢复技术" class="headerlink" title="第十章 数据库恢复技术"></a>第十章 数据库恢复技术</h2><h4 id="1-事务？事务的四个特性？"><a href="#1-事务？事务的四个特性？" class="headerlink" title="*1.事务？事务的四个特性？"></a>*1.事务？事务的四个特性？</h4><div class="code-wrapper"><pre><code class="hljs">事务：使用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割工作单位，也是数据库恢复和并发控制的基本单位。(1)原子性(atomicity)：事务时数据库的逻辑工作单位，事务中包括的诸操作要么都做，要么全不做。(2)一致性(consistency)：事务执行的结果必须是从一个一致性状态变到另一个一致性状态。(3)隔离性(isolation)：一个事务的执行不能被其他事务干扰。(4)持续性(durability)：一个事务一旦提交，它对数据库中数据的改变就应该是永久性。</code></pre></div><h4 id="2-为什么事务非正常结束时会影响数据库数据的正确性？"><a href="#2-为什么事务非正常结束时会影响数据库数据的正确性？" class="headerlink" title="2.为什么事务非正常结束时会影响数据库数据的正确性？"></a>2.为什么事务非正常结束时会影响数据库数据的正确性？</h4><div class="code-wrapper"><pre><code class="hljs">事物具有一致性，事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。</code></pre></div><h4 id="3-数据库恢复的关键是什么？数据库恢复的基本技术有哪些？"><a href="#3-数据库恢复的关键是什么？数据库恢复的基本技术有哪些？" class="headerlink" title="*3.数据库恢复的关键是什么？数据库恢复的基本技术有哪些？"></a>*3.数据库恢复的关键是什么？数据库恢复的基本技术有哪些？</h4><div class="code-wrapper"><pre><code class="hljs">关键是建立冗余数据；建立冗余数据最常用的技术：数据转储和登录日志文件。 数据转储：指DBA定期将数据库复制到其他介质上进行保存，这些备份的数据叫做后备副本；*登记日志文件：日志文件是用来记录事物对数据库进行更新操作的文件。当系统运行过程中发生故障，利用转储的数据库后备副本和日志文件就可以将数据库恢复到故障前的某个一致性状态。</code></pre></div><h4 id="4-登记日志文件时为什么必须先写日志文件，后写数据库？"><a href="#4-登记日志文件时为什么必须先写日志文件，后写数据库？" class="headerlink" title="4.登记日志文件时为什么必须先写日志文件，后写数据库？"></a>4.登记日志文件时为什么必须先写日志文件，后写数据库？</h4><div class="code-wrapper"><pre><code class="hljs">把对数据的修改写到数据库中 和 把表示这个修改的日志记录写到日志文件中 是两个不同的操作。有可能在这两个操作之间发生故障，即这两个写操作只完成了一个。如果先写了数据库修改，而在运行记录中没有登记这个修改，则以后就无法恢复这个修改了。如果先写日志，但没有修改数据库，在恢复时并不会影响数据库的正确性。所以一定要先写日志文件，即首先把日志记录写到日志文件中，然后写数据库的修改。</code></pre></div><h4 id="5-数据库故障的种类有哪几种？相应的恢复策略是什么？"><a href="#5-数据库故障的种类有哪几种？相应的恢复策略是什么？" class="headerlink" title="5.数据库故障的种类有哪几种？相应的恢复策略是什么？"></a>5.数据库故障的种类有哪几种？相应的恢复策略是什么？</h4><div class="code-wrapper"><pre><code class="hljs">三种：事物故障、系统故障、介质故障；事物故障是指事物在运行至终点前被中止；事物故障恢复是由系统自动完成，利用日志文件撤销此事务已对数据库进行的修改；系统故障是指造成系统停止运转的任何事件，使得系统要重新启动；系统故障的恢复是在重新启动后系统自动完成，为了防止系统故障造成的数据不一致性，必须撤销故障时未完成的事物，重做已完成的事物；介质故障是指磁盘上的物理数据和日志文件被破坏；介质故障的恢复方法就是重装数据库，重做已经完成的事物。</code></pre></div><h4 id="6-什么是检查点记录？检查点记录包括哪些内容？为什么需要检查点？"><a href="#6-什么是检查点记录？检查点记录包括哪些内容？为什么需要检查点？" class="headerlink" title="6.什么是检查点记录？检查点记录包括哪些内容？为什么需要检查点？"></a>6.什么是检查点记录？检查点记录包括哪些内容？为什么需要检查点？</h4><div class="code-wrapper"><pre><code class="hljs">检查点记录是一类新的日志记录，它的内容包括：(1)建立检查点时刻所有正在执行的事务清单。(2)这些事务的最近一个日志记录的地址搜索整个日志文件需要耗费的时间很多，重做处理，重新执行，耗费了大量的时间。</code></pre></div><h4 id="7-什么是数据库镜像？有什么用途？"><a href="#7-什么是数据库镜像？有什么用途？" class="headerlink" title="7.什么是数据库镜像？有什么用途？"></a>7.什么是数据库镜像？有什么用途？</h4><div class="code-wrapper"><pre><code class="hljs">数据库镜像即根据DBA的要求，自动把整个数据库或其中的部分关键数据复制到另一个磁盘上，每当主数据库更新时，DBMS自动把更新后的数据复制过去，即DBMS自动保证镜像数据与主数据的一致性。用途：(1)用于数据库恢复。当出现介质故障时，镜像磁盘可以继续使用，同时DBMS自动利用镜像磁盘数据进行数据库的儿回复，不需要关闭系统和重装数据库副本。(2)提高数据库的可用性。在没有出现故障时，当一个用户对某个数据加排他锁进行修改时，其他用户可以读镜像数据库上的数据，而不必等待用户释放锁。</code></pre></div><h4 id="8-在系统故障的恢复策略中，为什么Undo处理反向扫描日志文件，而redo处理正向扫描日志文件。"><a href="#8-在系统故障的恢复策略中，为什么Undo处理反向扫描日志文件，而redo处理正向扫描日志文件。" class="headerlink" title="*8.在系统故障的恢复策略中，为什么Undo处理反向扫描日志文件，而redo处理正向扫描日志文件。"></a>*8.在系统故障的恢复策略中，为什么Undo处理反向扫描日志文件，而redo处理正向扫描日志文件。</h4><div class="code-wrapper"><pre><code class="hljs">如果存在同一个数据的多个undo操作，需要将数据恢复到第一个失败事务之前，如果正向扫描处理日志文件则无法实现这一目标，因此应反向扫描日志文件。对于同一数据的多个redo操作，需要将数据恢复到最后一个成功事务之后，因此应该正向扫描日志文件。</code></pre></div><hr><hr><h2 id="第十一章-并发控制"><a href="#第十一章-并发控制" class="headerlink" title="第十一章 并发控制"></a>第十一章 并发控制</h2><h4 id="1-在数据库中为什么要并发控制？"><a href="#1-在数据库中为什么要并发控制？" class="headerlink" title="1.在数据库中为什么要并发控制？"></a>1.在数据库中为什么要并发控制？</h4><div class="code-wrapper"><pre><code class="hljs">数据库是共享资源，通常有多个事物在同时执行，当多个事物并发的存取数据库时就会存在同时读或写同一数据的情况，如果对并发操作不加控制，就会存在数据读取或存取错误，破坏数据库的一致性。并发控制可以保证事务的一致性和隔离性。</code></pre></div><h4 id="2-并发造成的数据不一致性包括什么？"><a href="#2-并发造成的数据不一致性包括什么？" class="headerlink" title="*2.并发造成的数据不一致性包括什么？"></a>*2.并发造成的数据不一致性包括什么？</h4><div class="code-wrapper"><pre><code class="hljs">丢失修改：A、B两个事物同时对一个数据进行操作，A的修改破坏了B的修改，导致B的修改丢失；不可重复读：A读取了数据后，B对数据进行了修改，导致A无法再现前一次的读取结果；读脏数据：A对数据进行了修改之后，B读入该数据，然后A又因为某一原因撤销了该修改，导致数据恢复原值，此时B读取的数据就成了脏数据。</code></pre></div><h4 id="3-什么是封锁？基本的封锁类型由哪几种？"><a href="#3-什么是封锁？基本的封锁类型由哪几种？" class="headerlink" title="*3.什么是封锁？基本的封锁类型由哪几种？"></a>*3.什么是封锁？基本的封锁类型由哪几种？</h4><div class="code-wrapper"><pre><code class="hljs">封锁就是事务T在对某个数据对象进行操作之前，先向系统发出请求，对其枷锁，加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其他事务不能更新或读取此数据对象。锁是最常用的并发控制机构，是防止其他事务访问指定资源，实现并发控制的一种手段。排他锁（X写锁）：当数据被加上写锁，其他事务不能对该数据进行读和写；共享锁（S读锁）：当数据被加上读锁，允许其他事务对该数据进行读，不允许写。</code></pre></div><h4 id="4-简要概括一、二、三级封锁协议"><a href="#4-简要概括一、二、三级封锁协议" class="headerlink" title="*4.简要概括一、二、三级封锁协议"></a>*4.简要概括一、二、三级封锁协议</h4><div class="code-wrapper"><pre><code class="hljs">一级封锁协议：事务在修改数据之前加写锁，直到事务结束才释放。该协议可以防止丢失修改；二级封锁协议：在一级封锁协议的基础上，加上了事务在读取数据之前对其加读锁，读完后即可释放读锁。该协议避免了读脏数据；三级封锁协议：在一级封锁协议的基础上，加上了事务在读取数据之前必须加上读锁，直到事务结束才释放。该协议解决了不可重复读问题。</code></pre></div><h4 id="5-什么是活锁？活锁的产生原因和解决方法？"><a href="#5-什么是活锁？活锁的产生原因和解决方法？" class="headerlink" title="5.什么是活锁？活锁的产生原因和解决方法？"></a>5.什么是活锁？活锁的产生原因和解决方法？</h4><div class="code-wrapper"><pre><code class="hljs">活锁的含义时该等待十五的等待时间太长，似乎被锁住了一样但实际上可能被激活。产生原因：当一系列封锁不能按照其先后顺序执行时，就可能导致一些事务无限期等待某个封锁，从而导致活锁。避免活锁的简单方法时采用先来先服务策略。</code></pre></div><h4 id="6-什么是死锁？预防死锁的方法？诊断解除死锁的方法？"><a href="#6-什么是死锁？预防死锁的方法？诊断解除死锁的方法？" class="headerlink" title="6.什么是死锁？预防死锁的方法？诊断解除死锁的方法？"></a>6.什么是死锁？预防死锁的方法？诊断解除死锁的方法？</h4><div class="code-wrapper"><pre><code class="hljs">出现T1等待T2，T2等待T1的局面，T1 T2两个事务永远不能结束 形成死锁。预防死锁要破坏死锁产生的条件，方法：(1)一次封锁法：要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。(2)顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务都按这个顺序来实行封锁。诊断死锁的方法：超时法或事务等待图法。解除方法：选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有锁，使其他事务得以运行下去。</code></pre></div><h4 id="7-什么样的并发调度是正确的调度？"><a href="#7-什么样的并发调度是正确的调度？" class="headerlink" title="7.什么样的并发调度是正确的调度？"></a>7.什么样的并发调度是正确的调度？</h4><div class="code-wrapper"><pre><code class="hljs">可串行话的调度是正确的调度可串行化定义：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行的执行它们时的结果相同，称这种调度策略为可串行化调度。</code></pre></div><h4 id="8-冲突可串行化调度？"><a href="#8-冲突可串行化调度？" class="headerlink" title="8.冲突可串行化调度？"></a>8.冲突可串行化调度？</h4><div class="code-wrapper"><pre><code class="hljs">冲突操作是指不同事务对同一事务的读写、写写操作一个调度S在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度S，如果S是串行的，则称调度S是冲突可串行化的调度。冲突可串行化调度——&gt;可串行化调度。</code></pre></div><h4 id="9-封锁粒度是什么？"><a href="#9-封锁粒度是什么？" class="headerlink" title="9.封锁粒度是什么？"></a>9.封锁粒度是什么？</h4><div class="code-wrapper"><pre><code class="hljs">封锁对象的大小称为封锁粒度。封锁粒度和系统并发性/系统开销密切上官，成反比。封锁的粒度越大，数据库能够封锁的数据单元就越少，并发度就越小，系统开销也就越小。封锁的粒度越小，数据库能够封锁的数据单元就越多，并发度就越高，系统开销也就越大。</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>【计算机考研复试】</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机考研复试】操作系统</title>
    <link href="/2022/03/10/operatingsystem/"/>
    <url>/2022/03/10/operatingsystem/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><hr><h2 id="第一章-OS概述"><a href="#第一章-OS概述" class="headerlink" title="第一章 OS概述  "></a>第一章 OS概述  </h2><h4 id="1-1-概念和功能"><a href="#1-1-概念和功能" class="headerlink" title="*1.1 概念和功能"></a>*1.1 概念和功能</h4><div class="code-wrapper"><pre><code class="hljs">概念：操作系统是指控制和管理整个计算机系统硬件和软件资源的最基本的系统软件。功能：（计算机系统自下而上分为：硬件、操作系统、应用程序、用户）    向上提供接口（用户：命令接口，编程员：程序接口）；    对下层功能的拓展；    对系统资源的管理（处理机、存储器、文件、设备）。</code></pre></div><h4 id="1-2-特征"><a href="#1-2-特征" class="headerlink" title="*1.2 特征"></a>*1.2 特征</h4><div class="code-wrapper"><pre><code class="hljs">并发性：指两个或多个事件在同一时间间隔内发生；（并行性：在同一时刻…）共享性：系统中的资源可供内存中多个并发执行的进程共同使用；虚拟性：把一个物理上的实体变成若干个逻辑上的对应物；异步性：进程的执行并不是一气呵成的，而是以不可预知的速度向前推进.</code></pre></div><h4 id="1-3-运行机制"><a href="#1-3-运行机制" class="headerlink" title="1.3 运行机制"></a>1.3 运行机制</h4><div class="code-wrapper"><pre><code class="hljs">CPU的两种状态用户态（目态）：不可以执行特权指令内核态（管态）CPU“变态”的唯一条件： 中断/异常实现“变态”的机制：通过硬件实现</code></pre></div><h4 id="1-4-中断和异常"><a href="#1-4-中断和异常" class="headerlink" title="1.4 中断和异常"></a>1.4 中断和异常</h4><div class="code-wrapper"><pre><code class="hljs">中断（外中断）：指来自CPU执行指令以外的事件发生；（如设备发出的I/O结束中断）异常（内中断、trap）：指源自CPU执行指令内部的事件.（如地址越界，算术溢出）</code></pre></div><h4 id="1-5系统调用"><a href="#1-5系统调用" class="headerlink" title="1.5系统调用"></a>1.5系统调用</h4><div class="code-wrapper"><pre><code class="hljs">概念：指用户在程序中调用OS所提供的一些功能。目的：用户必须通过调用系统调用才能操作系统资源（OS代为完成），以保证系统稳定性和安全性。</code></pre></div><h4 id="1-6处理器为什么要区分核心态和用户态？在什么情况下进行两种方式的切换？"><a href="#1-6处理器为什么要区分核心态和用户态？在什么情况下进行两种方式的切换？" class="headerlink" title="1.6处理器为什么要区分核心态和用户态？在什么情况下进行两种方式的切换？"></a>1.6处理器为什么要区分核心态和用户态？在什么情况下进行两种方式的切换？</h4><div class="code-wrapper"><pre><code class="hljs">区分执行态的主要目的时保护系统程序。用户态到核心态的转换发生在中断产生时，而核心态到用户态的转换则发生在中断返回用户程序时。</code></pre></div><hr><hr><h2 id="第2章-进程管理"><a href="#第2章-进程管理" class="headerlink" title="第2章 进程管理"></a>第2章 进程管理</h2><h4 id="2-1-进程的概述"><a href="#2-1-进程的概述" class="headerlink" title="2.1 进程的概述"></a>2.1 进程的概述</h4><div class="code-wrapper"><pre><code class="hljs">概念：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。组成：    PCB：进程存在的唯一标志    程序段    相关数据段引入进程的目的：为了更好地使多道程序并发执行，提高资源利用率和系统吞吐量。特征：    动态性：进程是程序的一次执行过程。进程是动态的，程序是静态的；    并发性：多个进程同时存在于内存中，能在一段时间内同时运行。引入进程的目的就是为了使程序能够并发运行；    独立性：进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。而程序不能作为一个独立的单位参与运行    异步性：异步性导致执行结果的不可再现性，因此OS中必须配置进程同步机制；    结构性：每一个进程都配置一个PCB对其进行描述。</code></pre></div><h4 id="2-2-进程的通信"><a href="#2-2-进程的通信" class="headerlink" title="2.2 进程的通信"></a>2.2 进程的通信</h4><div class="code-wrapper"><pre><code class="hljs">方式：低级通信方式：PV操作高级通信方式：共享存储、消息传递、管道通信</code></pre></div><h4 id="2-3-线程"><a href="#2-3-线程" class="headerlink" title="2.3 线程"></a>2.3 线程</h4><div class="code-wrapper"><pre><code class="hljs">概念：线程时进程中的一个实体，是被系统独立调度和分派的基本单位。 引入线程的目的：为了减小程序在并发执行的过程中所付出的时空开销，提高操作系统的并发性能。</code></pre></div><h4 id="2-4-线程与进程的比较"><a href="#2-4-线程与进程的比较" class="headerlink" title="2.4 线程与进程的比较"></a>2.4 线程与进程的比较</h4><table><thead><tr><th>比较</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>调度</td><td>仅是资源分配的基本单位</td><td>独立调度、分派的基本单位</td></tr><tr><td>并发性</td><td>仅进程间并发</td><td>进程间、线程间并发</td></tr><tr><td>拥有资源</td><td>资源拥有的基本单位</td><td>基本上不拥有资源</td></tr><tr><td>系统开销</td><td>创建、撤销、切换开销大</td><td>仅保存少量寄存器内容，开销小</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs">线程的实现方式：    用户级线程：线程的管理工作都由应用程序完成，应用程序通过使用线程库实现多线程程序；    内核级线程：线程的所有工作由内核完成。</code></pre></div><h4 id="2-5-处理及调度？"><a href="#2-5-处理及调度？" class="headerlink" title="2.5 处理及调度？"></a>2.5 处理及调度？</h4><div class="code-wrapper"><pre><code class="hljs">处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法选择一个进程，并将处理机分配给它运行。调度方式：非抢占式、抢占式调度的性能准则：    CPU利用率：应该尽量使CPU处于“忙”状态；    系统吞吐量：表示单位时间内系统完成作业的数量；    周转时间：作业从提交到完成的时间；    等待时间：处于等处理机状态的时间；    响应时间：从用户提交到系统首次响应。调度算法：    FCFS、SJF、优先级、高响应比、时间片轮转、多级反馈队列</code></pre></div><h4 id="2-6-进程同步与互斥"><a href="#2-6-进程同步与互斥" class="headerlink" title="2.6 进程同步与互斥"></a>2.6 进程同步与互斥</h4><div class="code-wrapper"><pre><code class="hljs">同步（直接制约关系）：指为完成某种任务而简历的两个或多个进程，这些进程因需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。互斥（间接制约关系）：当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一个进程才允许去访问此临界资源。临界资源：一次仅允许一个进程使用的资源，必须互斥访问；临界区：每个进程中，访问临界资源的那段代码。（进入区、临界区、退出区、剩余区）实现进程互斥的方法软件实现方法：在进入区设置并检查一些标志来标明是否有进程在临界区中，若有，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。硬件实现方法：中断屏蔽法：使用“开/关中断”指令，禁止一切中断的发生，只适合单CPU、OS内核进程；硬件指令法（TSL/Swap）：原子操作，适合多处理机。</code></pre></div><h4 id="2-7-举例解释一下同步和互斥"><a href="#2-7-举例解释一下同步和互斥" class="headerlink" title="*2.7 举例解释一下同步和互斥"></a>*2.7 举例解释一下同步和互斥</h4><div class="code-wrapper"><pre><code class="hljs">同步表现为直接制约，如管道通信，一个进程写，一个进程读，它们是相互制约的。互斥表现为间接制约，比如多个进程同时请求打印机（无SPOOLing技术时）</code></pre></div><h4 id="2-8-原语？"><a href="#2-8-原语？" class="headerlink" title="2.8 原语？"></a>2.8 原语？</h4><div class="code-wrapper"><pre><code class="hljs">原语是指完成某种功能且不被分割、不被中断执行的操作序列。</code></pre></div><h4 id="2-9-管程？"><a href="#2-9-管程？" class="headerlink" title="*2.9 管程？"></a>*2.9 管程？</h4><div class="code-wrapper"><pre><code class="hljs">管程是由一组局部变量、对局部变量进行操作的一组过程和对局部变量进行初始化的语句序列组成。引入的原因是因为P/V操作太过分散，对它的维护很麻烦且容易造成死锁。组成：    局部于管程的数据结构；    对数据结构进行操作的函数过程；    数据结构的初始化。基本特性：局部于管程的数据只能被局部于管程的过程所访问；一个进程只能通过调用管程内的过程才能进入管程访问共享数据；每次仅允许一个进程在管程内执行某个内部过程。</code></pre></div><h4 id="2-10-死锁？"><a href="#2-10-死锁？" class="headerlink" title="*2.10 死锁？"></a>*2.10 死锁？</h4><div class="code-wrapper"><pre><code class="hljs">定义：    多个进程因竞争资源而造成的一种互相等待的局面，若无外力作用，这些进程将无法向前推进。产生的原因：    系统资源的竞争、进程推进顺序不当。产生的必要条件：    互斥条件、不可剥夺条件、请求并保持条件、循环等待条件死锁的处理策略：    死锁预防：设置某些限制条件，破坏死锁的4个必要条件中的一个或几个，以防止死锁的发生；    死锁避免：在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁；    死锁的检测与解除：通过系统的检测机构及时地检测出死锁的发生，然后采取某些措施解除死锁。死锁预防：    破坏互斥条件：使系统资源都能共享；    （这种方法不太可行）    破坏不剥夺条件：当进程已保持了一些不可剥夺资源且又申请新的资源而得不到满足时，它必须释放已经保持的所有资源，待需要时重新申请；    （这种方法实现复杂，会增加系统开销，降低系统吞吐量）    破坏请求并保持状态：进程在运行前一次性申请完他所需要的全部资源；    （这种方法实现简单，但是会严重浪费系统资源，还会导致饥饿现象）    破坏循环等待状态：给系统中的资源编号，规定每个进程必须按照编号递增的顺序请求资源，同类资源一次申请完；    （这种方法限制了新类型设备的增加，给用户编程带来麻烦）避免死锁概念：进程可以动态地申请资源，但系统在进行资源分配前，需要先计算此资源分配的安全性，若此次分配不会导致系统进入不安全状态则分配，否则让进程等待。安全序列：    指系统能按照某种顺序为每个进程分配其所需的资源，直到满足每个进程对资源的最大需求，使得每个进程都可以顺利完成。（并非所有的不安全状态都是死锁状态，反之，只要系统处于安全状态，就不会进入死锁状态）死锁的检测与解除资源分配图死锁定理：死锁的条件是当且仅当资源分配图是不可完全简化的。死锁解除</code></pre></div><h4 id="2-11-什么是安全状态？当系统不安全时就是系统进入了死锁状态吗？"><a href="#2-11-什么是安全状态？当系统不安全时就是系统进入了死锁状态吗？" class="headerlink" title="*2.11 什么是安全状态？当系统不安全时就是系统进入了死锁状态吗？"></a>*2.11 什么是安全状态？当系统不安全时就是系统进入了死锁状态吗？</h4><div class="code-wrapper"><pre><code class="hljs">安全状态是指系统按照某种进程顺序，为进程分配资源，使得每个进程都能获取所需的最大资源，并顺利完成。不是，但是死锁状态一定是不安全状态。</code></pre></div><h4 id="2-12-简述银行家算法？"><a href="#2-12-简述银行家算法？" class="headerlink" title="2.12 简述银行家算法？"></a>2.12 简述银行家算法？</h4><div class="code-wrapper"><pre><code class="hljs">银行家算法是最著名的死锁避免算法，其思想是：避免系统进入不安全状态。在每次进行资源分配时，它首先检查系统是否有足够的资源满足要求，若有则先进行分配，并对分配后的新状态进行安全性检查。若新状态安全，则正式分配上述资源，否则拒绝分配上述资源。这样，它保证系统始终处于安全状态，从而避免了死锁现象的发生。</code></pre></div><h4 id="2-13-简述进程和程序的区别。"><a href="#2-13-简述进程和程序的区别。" class="headerlink" title="*2.13 简述进程和程序的区别。"></a>*2.13 简述进程和程序的区别。</h4><div class="code-wrapper"><pre><code class="hljs">进程和程序是既有联系又有区别。主要区别：1.程序是指令的有序集合，其本身没有任何运行的含义，它是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个动态概念。2.程序的存在是永久的，而进程则是有生命的，它因创建而产生，因调度而执行，因得不到资源而暂停，因撤销而消亡。3.程序仅是指令的有序集合。而进程则是由程序、数据和进程控制块组成。</code></pre></div><hr><hr><h2 id="第三章-内存管理"><a href="#第三章-内存管理" class="headerlink" title="第三章 内存管理"></a>第三章 内存管理</h2><h4 id="3-1-内存管理的功能"><a href="#3-1-内存管理的功能" class="headerlink" title="3.1 内存管理的功能"></a>3.1 内存管理的功能</h4><div class="code-wrapper"><pre><code class="hljs">内存的分配与回收地址转换内存空间的扩充存储保护</code></pre></div><h4 id="3-2-进程运行的基本原理"><a href="#3-2-进程运行的基本原理" class="headerlink" title="3.2 进程运行的基本原理"></a>3.2 进程运行的基本原理</h4><div class="code-wrapper"><pre><code class="hljs">从写程序到程序运行生成源代码文件    编译：编译程序将源代码编译成若干的目标模块；    链接：由链接程序将目标模块与所需库函数链接成一个完整的装入模块；    装入：由装入程序将装入模块装入内存运行。三种链接方式（生成逻辑地址）：    静态链接：在 程序运行之前链接成一个可执行程序；    装入时动态链接：在装入内存时，采用 边装入边链接的方法；    运行时动态链接：在程序 运行时需要该目标模块再链接。便于修改和更新，有利于目标模块的共享。三种装入方式（生成物理地址）：    绝对装入：在单道程序环境下，编译时知道程序的实际存储位置，则编译时产生绝对地址的目标代码，即 逻辑地址与物理地址相同；    可重定位装入（静态重定位）：在多道程序环境下，目标模块的起始地址通常是从0开始，装入时，将目标程序的逻辑地址 一次性换为物理地址；    动态运行时装入（动态重定位）：程序可以可以在内存中发生移动，需要设置一个重定位寄存器，装入时，目标程序的逻辑地址 不需要立即转换为物理地址，可以需要的时候再换。</code></pre></div><h4 id="3-3-内存扩充：覆盖与交换"><a href="#3-3-内存扩充：覆盖与交换" class="headerlink" title="3.3 内存扩充：覆盖与交换"></a>3.3 内存扩充：覆盖与交换</h4><div class="code-wrapper"><pre><code class="hljs">覆盖技术：    基本思想：将用户空间分为一个固定区和若干个覆盖区。    固定区：存放最活跃的程序段，程序运行时不会调入调出；    覆盖区：不会被同时访问的程序段共享一个覆盖区，根据需要进行调入调出；    特点：打破了必须将一个进程的全部信息装入内存后才能运行的限制。交换技术：    基本思想：（中级调度时采用）    换出：内存紧张时，将处于等待状态的进程从内存调到辅存；    换入：把准备好竞争CPU的进程从辅存移到内存中。    特点：把磁盘空间分为文件区和交换区二者区别：覆盖技术常用于 同一个程序或进程中，而交换技术则在 不同进程或程序之间进行；覆盖技术必须由程序员声明覆盖结构，使得对用户和程序员 不透明。</code></pre></div><h4 id="3-4-连续内存分配"><a href="#3-4-连续内存分配" class="headerlink" title="3.4 连续内存分配"></a>3.4 连续内存分配</h4><div class="code-wrapper"><pre><code class="hljs">概念：为一个用户程序分配一个连续的内存空间。三种方式：单一连续分配、固定分区分配、动态分区分配单一连续分配：    只支持单道程序，内存分为系统区和用户区；    无外部碎片，有内部碎片；    可以采用 覆盖交换技术。固定分区分配：    支持多道程序，内存分为若干固定分区；    无外部碎片，有内部碎片；    为分区建立一张 分区说明表，分区大小可以相等或不等。动态分区分配：    特点：    支持多道程序，根据进程大小动态分区；    无内部碎片，有外部碎片；    外部碎片采用 “紧凑”技术得以解决：操作系统不时的对进程进行移动和整理，需要采用 动态重定位寄存器。</code></pre></div><h4 id="3-5-4种动态分区分配算法："><a href="#3-5-4种动态分区分配算法：" class="headerlink" title="3.5 4种动态分区分配算法："></a>3.5 4种动态分区分配算法：</h4><div class="code-wrapper"><pre><code class="hljs">首次适应：地址递增，顺序查找；最佳适应：容量递增，依次查找；最坏适应：容量递减，依次查找；邻近适应：在首次适应的基础上，按照从上次结束的位置进行依次查找。</code></pre></div><h4 id="3-6-非连续分配管理"><a href="#3-6-非连续分配管理" class="headerlink" title="3.6 非连续分配管理"></a>3.6 非连续分配管理</h4><div class="code-wrapper"><pre><code class="hljs">概念：为一个用户程序分配不连续的内存空间。基本方法：分页存储管理、分段存储管理分页存储管理    分页的原理：把主存空间划分为大小相等且固定的块，作为主存的基本单位；每个进程也以块为单位划分，进程执行时，以块为单位申请内存空间。基本地址变换机构    具有快表的地址变换机构：先到高速缓冲寄存器中找，再去内存中的页表里找，减少了访存次数；    两级页表：页表存放在内存中，若大量无用的页表存放在主存中会造成内存浪费，因此建立多级页表，其目的在于建立索引，以便不浪费主存空间去存储无用的页表项，也不用盲目的顺序式查找页表项。分段存储管理    分段的特点：将地址空间按程序自身逻辑分段；每个段在内存中占连续空间，各段可不相邻。</code></pre></div><h4 id="3-7-分段和分页的主要区别："><a href="#3-7-分段和分页的主要区别：" class="headerlink" title="*3.7 分段和分页的主要区别："></a>*3.7 分段和分页的主要区别：</h4><div class="code-wrapper"><pre><code class="hljs">目的：分页的为了满足系统管理的需要，分段是为了满足用户的需要；大小：页的大小是固定的，段的大小是不固定的；维度：页的地址是一维的，段的地址是二维的；碎片：分页有内部碎片无外部碎片，分段有外部碎片无内部碎片。</code></pre></div><h4 id="3-8-虚拟内存、虚拟存储器？"><a href="#3-8-虚拟内存、虚拟存储器？" class="headerlink" title="3.8 虚拟内存、虚拟存储器？"></a>3.8 虚拟内存、虚拟存储器？</h4><div class="code-wrapper"><pre><code class="hljs">局部性原理：    时间局部性：当前所访问的数据，很可能再次被访问；    空间局部性：当前所访问的存储单元，其周围的存储单元很可能下次被访问。虚拟存储器的定义和主要特性：    定义：基于局部性原理，系统利用部分调用、请求调入、置换功能，好像为用户提供了一个比实际内存大得多的存储器；    主要特性：        多次性：作业无须一次调入，允许分多次调入内存；        对换性：作业在运行过程中无须常驻内存，可以根据需要进行换入换出；        虚拟性：从逻辑上扩充内存容量。虚拟内存技术的实现：    三种方式：请求分页存储管理、请求分段存储管理、请求段页式存储管理    硬件支持：页表机制、缺页中断机构、地址变换机构</code></pre></div><h4 id="3-9-请求分页管理方式"><a href="#3-9-请求分页管理方式" class="headerlink" title="3.9 请求分页管理方式"></a>3.9 请求分页管理方式</h4><div class="code-wrapper"><pre><code class="hljs">请求分页系统建立在基本分页系统的基础上，为了实现虚拟存储功能而增加了请求调页功能和页面置换功能。页表机制：    在基本分页系统的基础上增加了4个字段：    状态位：用于指示该页是否已经调入内存；    访问字段：用于记录本页在一段时间内被访问的次数，供置换算法参考；    修改位：标记在调入内存后该页是否被修改过；    外存地址：用于指出该页在外存上的地址，供调入页面时参考。缺页中断机构：    在请求分页系统中，当所要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。地址变换机构：    找到页表项要检查页面是否在内存中；若在，则修改页表项中的访问位，得出物理地址，若不在，请求调页，调入时，若内存不够，进行页面置换。</code></pre></div><h4 id="3-11-试述缺页中断与一般中断有何区别？"><a href="#3-11-试述缺页中断与一般中断有何区别？" class="headerlink" title="*3.11 试述缺页中断与一般中断有何区别？"></a>*3.11 试述缺页中断与一般中断有何区别？</h4><div class="code-wrapper"><pre><code class="hljs">缺页中断的处理过程与一般中断相似。主要区别：1.在指令执行期间产生和处理中断信号。2.一条指令在执行期间可能产生多次缺页中断。</code></pre></div><h4 id="3-12-页面置换算法"><a href="#3-12-页面置换算法" class="headerlink" title="3.12 页面置换算法"></a>3.12 页面置换算法</h4><div class="code-wrapper"><pre><code class="hljs">最佳置换算法：淘汰的页面时未来最长时间不会被使用的；先进先出算法：优先淘汰最先被调入的页面；最近最久未使用算法：优先淘汰最近最长时间为被访问的页面；时钟置换算法（最近未用算法）：循环扫描缓冲区，优先淘汰未使用过的页面。改进的时钟算法：循环扫描缓冲区，若有未使用过的页面，则当然首先把它换出，若全部页面使用过，则当然优先把未修改过的页面换出。</code></pre></div><h4 id="3-13-简述一下Clock置换算法"><a href="#3-13-简述一下Clock置换算法" class="headerlink" title="3.13 简述一下Clock置换算法"></a>3.13 简述一下Clock置换算法</h4><div class="code-wrapper"><pre><code class="hljs">该算法为每个页面设置一位访问位，将内存中的所有页面通过指针链成一个循环队列。由于该算法只有一位访问位，只能用它表示该页是否已经使用过，而置换时是将最近未使用过的页面换出去，所以把该算法称为最近未用算法。选择页置换的过程：1.当某页被访问时，其访问位置“1”；2.在选择一页淘汰时，就检查其访问位，如果是“0”，就选择该页换出；若为“1”，则重新置为“0”，暂不换出该页；3.在循环队列中检查下一个页面，直到访问到访问位为“0”的页面为止。</code></pre></div><h4 id="3-14-页面分配策略"><a href="#3-14-页面分配策略" class="headerlink" title="3.14 页面分配策略"></a>3.14 页面分配策略</h4><div class="code-wrapper"><pre><code class="hljs">驻留集：请求分页存储管理中，给一个进程分配的物理页框的集合就是这个进程的驻留集。页面分配策略：固定分区局部置换、可变分配全局置换、可变分区局部置换抖动：刚换出的页面马上又要换入主存，或者反之。    主要原因：某个进程频繁访问的页面数目高于可用的物理页框数目工作集：在某段时间间隔内，进程要访问的页面集合。</code></pre></div><hr><hr><h2 id="第4章-文件管理"><a href="#第4章-文件管理" class="headerlink" title="第4章 文件管理"></a>第4章 文件管理</h2><h4 id="4-1-文件管理的概述"><a href="#4-1-文件管理的概述" class="headerlink" title="4.1 文件管理的概述"></a>4.1 文件管理的概述</h4><div class="code-wrapper"><pre><code class="hljs">文件的定义：一组有意义的信息集合，可以是文档、图片、程序等。在用户进行输入、输出时，以文件为基本单位。文件的基本操作：操作系统提供 系统调用对文件进行创建、读、写、重定位、删除和截断等操作。</code></pre></div><h4 id="4-2-文件的逻辑结构"><a href="#4-2-文件的逻辑结构" class="headerlink" title="4.2 文件的逻辑结构"></a>4.2 文件的逻辑结构</h4><div class="code-wrapper"><pre><code class="hljs">文件的逻辑结构是从用户观点出发看到的文件的组织形式。文件的物理结构是从实现观点出发看到的文件在外存上的存储组织形式。无结构文件（流式文件）有结构文件（有记录文件）：    顺序文件    索引文件    索引顺序文件    直接（散列）文件</code></pre></div><h4 id="4-4-文件物理结构"><a href="#4-4-文件物理结构" class="headerlink" title="4.4 文件物理结构"></a>4.4 文件物理结构</h4><div class="code-wrapper"><pre><code class="hljs">连续分配：    支持顺序访问和直接访问    优点是实现简单、存取速度快    缺点是文件长度不宜动态增加链接分配：    隐式链接：每个文件对应一个磁盘块的链表；磁盘块分布在磁盘的任何地方，除最后一个盘块外，每个盘块都有指向下一个盘块的指针。    显示连接：把用于链接文件各物理块的指针，从每个物理块的块末尾中提取出来，显式的存放在内存的一张链表中，成为文件分配表。索引分配</code></pre></div><h4 id="4-5-文件共享"><a href="#4-5-文件共享" class="headerlink" title="4.5 文件共享"></a>4.5 文件共享</h4><div class="code-wrapper"><pre><code class="hljs">基于索引节点的共享方式（硬链接）利用符号链实现文件共享（软链接）（类似于快捷方式）</code></pre></div><h4 id="4-6-文件保护"><a href="#4-6-文件保护" class="headerlink" title="4.6 文件保护"></a>4.6 文件保护</h4><div class="code-wrapper"><pre><code class="hljs">概念：为了防止文件共享可能会导致文件被破坏或未经批准的用户修改文件，文件系统必须控制用户对文件的存取，为此必须建立保护机制。方式：口令保护、加密保护、访问控制</code></pre></div><h4 id="4-7-文件存储空间管理"><a href="#4-7-文件存储空间管理" class="headerlink" title="4.7 文件存储空间管理"></a>4.7 文件存储空间管理</h4><div class="code-wrapper"><pre><code class="hljs">存储空间的划分与初始化：文件存储设备分成许多大小相同的物理块，并以块为单位交换信息，因此，文件存储设备的管理实质上是对空闲块的组织和管理，它包括空闲块的组织、分配与回收    空闲表法：    空闲链表法：    位示图法：    成组链接法：</code></pre></div><h4 id="4-8-文件目录和目录文件的区别？目前广泛采用的目录结构形式是哪种？有何优点？"><a href="#4-8-文件目录和目录文件的区别？目前广泛采用的目录结构形式是哪种？有何优点？" class="headerlink" title="4.8 文件目录和目录文件的区别？目前广泛采用的目录结构形式是哪种？有何优点？"></a>4.8 文件目录和目录文件的区别？目前广泛采用的目录结构形式是哪种？有何优点？</h4><div class="code-wrapper"><pre><code class="hljs">文件目录，又称文件控制块，存储的是文件的管理信息，控制对象是单个文件；目录文件，存储的是若干个文件目录，控制对象是整个文件系统；目前广泛采用的树形目录结构，优点是：允许文件重命名，实现了文件分类。</code></pre></div><h4 id="4-9-磁盘调度算法"><a href="#4-9-磁盘调度算法" class="headerlink" title="4.9 磁盘调度算法"></a>4.9 磁盘调度算法</h4><div class="code-wrapper"><pre><code class="hljs">4种算法：先来先服务算法最短寻找时间优先算法扫描算法（电梯调度算法）循环扫描算法</code></pre></div><h2 id="第五章-输入-x2F-输出管理"><a href="#第五章-输入-x2F-输出管理" class="headerlink" title="第五章 输入&#x2F;输出管理"></a>第五章 输入&#x2F;输出管理</h2><h4 id="5-1-I-x2F-O控制方式"><a href="#5-1-I-x2F-O控制方式" class="headerlink" title="5.1 I&#x2F;O控制方式"></a>5.1 I&#x2F;O控制方式</h4><div class="code-wrapper"><pre><code class="hljs">程序直接控制方式:    工作原理：外设与内存进行数据传输时，每传输一个字，CPU都需要进行循环检查，判断是否已经传输完成。    传输单位：字    数据流向：设备与CPU之间、CPU与内存之间    CPU干预频率：极高    特点：造成了CPU的极大浪费，使其一直处于“忙等”。中断驱动方式:    工作原理：外设要和内存进行数据传输时，允许外设打断CPU运行并请求服务，使得CPU需要在每个指令周期末检查是否有中断，若有中断，则要处理中断，，然后CPU又返回做原来的工作。    传输单位：字    数据流向：设备与CPU之间、CPU与内存之间    CPU干预频率：高DMA方式:    工作原理：允许主存和外设在DMA控制器下进行直接交互，在数据传输的整个过程中不需要CPU的参与。    传输单位：块    数据流向：设备和内存之间    CPU干预频率：中等通道控制方式    工作原理：是专门负责输入输出的处理机。对DMA方式的改进，可以把对一个数据块的干预减少到对一组数据块的干预。    传输单位：一组块    数据流向：设备和内存之间    CPU干预频率：低</code></pre></div><h4 id="5-2-什么是-DMA-方式？它与中断方式的主要区别是什麽？"><a href="#5-2-什么是-DMA-方式？它与中断方式的主要区别是什麽？" class="headerlink" title="#5.2 什么是 DMA 方式？它与中断方式的主要区别是什麽？"></a>#5.2 什么是 DMA 方式？它与中断方式的主要区别是什麽？</h4><div class="code-wrapper"><pre><code class="hljs">DMA方式是指内存与外设只需要在DMA控制器的控制下进行数据传输，而不需要进行CPU的干预。与中断方式的主要区别是：1.中断方式在每个数据需要传输时都需要中断CPU，而DMA方式是在所要求传送的一批数据全部传送完毕时才中断CPU；2.中断方式中数据传输是在中断处理时由CPU控制完成的，而DMA方式中数据传输是在DMA控制器控制下完成的。</code></pre></div><h4 id="5-3-I-x2F-O子系统的层次结构"><a href="#5-3-I-x2F-O子系统的层次结构" class="headerlink" title="5.3 I&#x2F;O子系统的层次结构"></a>5.3 I&#x2F;O子系统的层次结构</h4><div class="code-wrapper"><pre><code class="hljs">层次组成:    用户层I/O软件：实现与用户交互的接口，用户可直接调用在用户层提供的、与I/O操作有关的库函数，对设备进行操作。    设备独立性软件：用于实现用户程序与设备驱动器的统一接口、设备命令、设备保护及设备分配与释放等，同时为设备管理和数据传送提供必要的存储空间。    设备驱动程序：与硬件直接线管，负责具体实现系统对设备发出的操作指令，驱动I/O设备工作的驱动程序    中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完并恢复被终端进程的现场后，返回到被中断进程。    硬件设备</code></pre></div><h4 id="5-4-缓冲区管理"><a href="#5-4-缓冲区管理" class="headerlink" title="*5.4 缓冲区管理"></a>*5.4 缓冲区管理</h4><div class="code-wrapper"><pre><code class="hljs">缓冲技术是一种 以空间换时间的资源换取技术。一般利用内存作为缓冲区。引入的目的：1.可以协调CPU与I/O设备之间速度不匹配的矛盾；2.可以减少对CPU的中断频率；3.提高设备的利用率。(总的来说，提高CPU利用率，提高并行度)。缓冲区类型：单缓冲、双缓冲、循环缓冲、缓冲池</code></pre></div><h4 id="5-5-设备的分配与回收"><a href="#5-5-设备的分配与回收" class="headerlink" title="5.5 设备的分配与回收"></a>5.5 设备的分配与回收</h4><div class="code-wrapper"><pre><code class="hljs">设备分配是指根据用户的I/O请求分配所需的设备。合理的分配原则主要考虑的因素：    I/O设备的固有属性、T/O设备的分配算法、I/O设备分配的安全性以及I/O设备的独立性。设备分配策略：    (1)设备分配原则：既要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体设备隔离开。    (2)设备分配方式：静态分配和动态分配    (3)设备分配算法：先请求先分配、优先级高者优先设备分配安全性：    设备分配中应防止发生进程死锁。</code></pre></div><h4 id="5-6-在设备管理中，何谓设备独立性？如何实现设备独立性？"><a href="#5-6-在设备管理中，何谓设备独立性？如何实现设备独立性？" class="headerlink" title="#5.6 在设备管理中，何谓设备独立性？如何实现设备独立性？"></a>#5.6 在设备管理中，何谓设备独立性？如何实现设备独立性？</h4><div class="code-wrapper"><pre><code class="hljs">设备独立性是指用户程序独立于所使用的具体设备。实现方式是系统为每个用户进程配置一张用于联系逻辑设备名和物理设备名的映射表，以实现使用逻辑设备名来请求物理设备。</code></pre></div><h4 id="5-7-SPOOLing技术"><a href="#5-7-SPOOLing技术" class="headerlink" title="5.7 SPOOLing技术"></a>5.7 SPOOLing技术</h4><div class="code-wrapper"><pre><code class="hljs">假脱机技术作用：为了缓和CPU的高速性与I/O设备低速性之间的矛盾，引入了脱机输入/输出技术。实现设备组成：    输入井和输出井    输入缓冲区和输出缓冲区    输入进程和输出进程</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>【计算机考研复试】</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【机器学习从入门到入土】</title>
    <link href="/2022/03/06/MachineLearn/"/>
    <url>/2022/03/06/MachineLearn/</url>
    
    <content type="html"><![CDATA[<h2 id="一、机器学习概述"><a href="#一、机器学习概述" class="headerlink" title="一、机器学习概述"></a>一、机器学习概述</h2><h3 id="1-什么是机器学习？"><a href="#1-什么是机器学习？" class="headerlink" title="1.什么是机器学习？"></a>1.什么是机器学习？</h3><p>机器学习是从大量的数据中自动分析获得规律（模型），并利用规律对未知数据进行预测。</p><h3 id="2-机器学习应用场景？"><a href="#2-机器学习应用场景？" class="headerlink" title="2.机器学习应用场景？"></a>2.机器学习应用场景？</h3><p>机器学习已广泛应用于数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和手写识别、战略游戏和机器人等领域.</p><h3 id="3-机器学习算法分类"><a href="#3-机器学习算法分类" class="headerlink" title="3.机器学习算法分类"></a>3.机器学习算法分类</h3><ol><li><p>监督学习(Supervised learning)，可以由输入数据中学<br>到或建立一个模型，并依此模式推测新的结果。输入数据是由<br>输入特征值和目标值所组成。函数的输出可以是一个连续的值<br>（称为回归），或是输出是有限个离散值（称作分类）。<br>分类算法： k-近邻算法、贝叶斯分类、决策树与随机森林、逻辑回归、神经网络<br>回归算法： 线性回归、岭回归</p></li><li><p>无监督学习：可以由输入数据中学到或建立一个模型，并依此模式推测新的结果。输入数据是由输入特征值所组成。</p></li></ol><p>聚类算法 K-means</p><h3 id="4-开发机器学习应用程序的步骤"><a href="#4-开发机器学习应用程序的步骤" class="headerlink" title="4.开发机器学习应用程序的步骤"></a>4.开发机器学习应用程序的步骤</h3><p>（1）收集数据<br>我们可以使用很多方法收集样本护具，如：制作网络爬虫从网站上抽取数据、从RSS反馈或者API中得到信息、设备发送过来的实测数据。<br>（2）准备输入数据<br>得到数据之后，还必须确保数据格式符合要求。<br>（3）分析输入数据<br>这一步的主要作用是确保数据集中没有垃圾数据。如果是使用信任的数据来源，那么可以直接跳过这个步骤<br>（4）训练算法<br>机器学习算法从这一步才真正开始学习。如果使用无监督学习算法，由于不存在目标变量值，故而也不需要训练算法，所有与算法相关的内容在第（5）步<br>（5）测试算法<br>这一步将实际使用第（4）步机器学习得到的知识信息。当然在这也需要评估结果的准确率，然后根据需要重新训练你的算法<br>（6）使用算法<br>转化为应用程序，执行实际任务。以检验上述步骤是否可以在实际环境中正常工作。如果碰到新的数据问题，同样需要重复执行上述的步骤</p><h2 id="二、特征工程"><a href="#二、特征工程" class="headerlink" title="二、特征工程"></a>二、特征工程</h2><h3 id="2-1-数据集"><a href="#2-1-数据集" class="headerlink" title="2.1 数据集"></a>2.1 数据集</h3><h4 id="1-Scikit-learn工具"><a href="#1-Scikit-learn工具" class="headerlink" title="1.Scikit_learn工具"></a>1.Scikit_learn工具</h4><p>python语言的机器学习工具</p><h4 id="2-sklearn数据集的使用"><a href="#2-sklearn数据集的使用" class="headerlink" title="2.sklearn数据集的使用"></a>2.sklearn数据集的使用</h4><p>sklearn数据集使用举例(以鸢尾花数据集举例)</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris<br><span class="hljs-comment"># 获取数据集</span><br>iris = load_iris()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;鸢尾花数据集：\n&quot;</span>, iris)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;查看数据集描述：\n&quot;</span>, iris[<span class="hljs-string">&quot;DESCR&quot;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;查看特征值的名字：\n&quot;</span>, iris.feature_names)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;查看特征值：\n&quot;</span>, iris.data, iris.data.shape)<br><br></code></pre></td></tr></table></figure><h4 id="3-数据集的划分"><a href="#3-数据集的划分" class="headerlink" title="3.数据集的划分"></a>3.数据集的划分</h4><p>机器学习一般的数据集会划分为两部分：<br>训练数据：用于训练，构建模型<br>测试数据：在模型检验时使用，用于评估模型是否有效<br>sklearn.model_selection.train_test_split(arrays,*option)</p><p>·test_size 测试集的大小<br>·random_state 随机数种子，不同的种子会造成不同的随机采样结果，相同的种子采样结果相同。<br>·return 训练集特征值，测试集特征值，训练集目标值，测试集目标值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">22</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练集的特征值：\n&quot;</span>, x_train, x_train.shape)<br></code></pre></td></tr></table></figure><h3 id="2-2-特征工程介绍"><a href="#2-2-特征工程介绍" class="headerlink" title="2.2 特征工程介绍"></a>2.2 特征工程介绍</h3><h4 id="1-为什么要有特征工程"><a href="#1-为什么要有特征工程" class="headerlink" title="1.为什么要有特征工程"></a>1.为什么要有特征工程</h4><p>数据决定了机器学习的上限，而算法只是尽可能逼近这个上限</p><h4 id="2-什么是特征工程"><a href="#2-什么是特征工程" class="headerlink" title="2.什么是特征工程"></a>2.什么是特征工程</h4><p>从数据中抽取出来对预测结果有用的信息，通过专业的技巧进行数据处理，使得特征能在机器学习算法中发挥更好的作用的过程。</p><h4 id="3-特征工程的意义"><a href="#3-特征工程的意义" class="headerlink" title="3.特征工程的意义"></a>3.特征工程的意义</h4><p>更好的特征意味着更强的鲁棒性<br>更好的特征意味着只需用简单模型<br>更好的特征意味着更好的结果</p><h4 id="4-特征抽取"><a href="#4-特征抽取" class="headerlink" title="4.特征抽取"></a>4.特征抽取</h4><h5 id="1-什么是特征抽取"><a href="#1-什么是特征抽取" class="headerlink" title="(1)什么是特征抽取"></a>(1)什么是特征抽取</h5><p>现实世界中多数特征都不是连续变量，比如分类、文字、图像等，为了对非连续变量做特征表述，需要对这些特征做数学化表述，因此就用到了特征提取.</p><h5 id="2-特征提取API"><a href="#2-特征提取API" class="headerlink" title="(2)特征提取API"></a>(2)特征提取API</h5><p>sklearn.feature_extraction</p><ol><li><p>字典特征提取<br>作用：对字典数据进行特征提取<br>sklearn.feature_extraction.DicVectorizer() 转换器类<br><img src="/2022/03/06/MachineLearn/1.png" alt="转换器参数详细"><br>操作流程：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">data = [&#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;北京&#x27;</span>,<span class="hljs-string">&#x27;temperature&#x27;</span>:<span class="hljs-number">100</span>&#125;, &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;上海&#x27;</span>,<span class="hljs-string">&#x27;temperature&#x27;</span>:<span class="hljs-number">60</span>&#125;, &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;深圳&#x27;</span>,<span class="hljs-string">&#x27;temperature&#x27;</span>:<span class="hljs-number">30</span>&#125;]<br><span class="hljs-comment"># 1、实例化一个转换器类</span><br>transfer = DictVectorizer(sparse=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 2、调用fit_transform()</span><br>data_new = transfer.fit_transform(data)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;data_new:\n&quot;</span>, data_new.toarray(), <span class="hljs-built_in">type</span>(data_new))<br><span class="hljs-comment">#需要toarray()方法转变为numpy的数组形式</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;特征名字：\n&quot;</span>, transfer.get_feature_names())<br></code></pre></td></tr></table></figure><p> 应用场景：<br> 1.数据集当中类别特征比较多<br> 将数据集的特征转换为字典类型<br> 字典特征提取<br> 2.本身拿到的数据就是字典类型</p></li><li><p>文本特征提取<br>文本的特征提取应用于很多方面，比如说文档分类、垃圾邮件分类和新闻分类。那么文本分类是通过词是否存在、以及词的概率（重要性）来表示。<br>作用：对文本数据进行特征化,对中文特征化要事先分词用jieba</p><p> sklearn.feature_extraction.text.CountVectorizer()<br> <img src="/2022/03/06/MachineLearn/2.png" alt="转换器参数详细"></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">data = [<span class="hljs-string">&quot;life is short,i like like python&quot;</span>, <span class="hljs-string">&quot;life is too long,i dislike python&quot;</span>]<br><span class="hljs-comment"># 1、实例化一个转换器类</span><br>transfer = CountVectorizer(stop_words=[<span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;too&quot;</span>])<br><span class="hljs-comment"># 2、调用fit_transform</span><br>data_new = transfer.fit_transform(data)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;data_new:\n&quot;</span>, data_new.toarray())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;特征名字：\n&quot;</span>, transfer.get_feature_names())<br></code></pre></td></tr></table></figure></li><li><p>中文特征处理</p><p> 中文进行特征化之前要先用Jieba进行分词处理<br> jieba的使用：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">进行中文分词：&quot;我爱北京天安门&quot; --&gt; &quot;我 爱 北京 天安门&quot;</span><br><span class="hljs-string">:param text:</span><br><span class="hljs-string">:return:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot; &quot;</span>.join(<span class="hljs-built_in">list</span>(jieba.cut(text)))<br></code></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">中文文本特征抽取，自动分词</span><br><span class="hljs-string">:return:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 将中文文本进行分词</span><br>data = [<span class="hljs-string">&quot;一种还是一种今天很残酷，明天更残酷，后天很美好，但绝对大部分是死在明天晚上，所以每个人不要放弃今天。&quot;</span>,<br>        <span class="hljs-string">&quot;我们看到的从很远星系来的光是在几百万年之前发出的，这样当我们看到宇宙时，我们是在看它的过去。&quot;</span>,<br>        <span class="hljs-string">&quot;如果只用一种方式了解某样事物，你就不会真正了解它。了解事物真正含义的秘密取决于如何将其与我们所了解的事物相联系。&quot;</span>]<br><br>data_new = []<br><span class="hljs-keyword">for</span> sent <span class="hljs-keyword">in</span> data:<br>    data_new.append(cut_word(sent))<br><span class="hljs-comment"># print(data_new)</span><br><span class="hljs-comment"># 1、实例化一个转换器类</span><br>transfer = CountVectorizer(stop_words=[<span class="hljs-string">&quot;一种&quot;</span>, <span class="hljs-string">&quot;所以&quot;</span>])<br><br><span class="hljs-comment"># 2、调用fit_transform</span><br>data_final = transfer.fit_transform(data_new)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;data_new:\n&quot;</span>, data_final.toarray())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;特征名字：\n&quot;</span>, transfer.get_feature_names())<br></code></pre></td></tr></table></figure><p> 上述运行结果：<br> <img src="/2022/03/06/MachineLearn/3.png" alt="运行结果"></p></li><li><p>Tf-idf文本特征提取</p></li></ol><p>思想：如果某一词在一篇文章中出现的概率高，并且在其他文章中很少出现，则认为该词有很好的类别区分能力，适合用来分类。<br>作用：用以评估一字词对于一个文件集或与个语料库中的其中一份文件的重要程度。<br>如果想找到文章中的关键词可以使用TfidfVectorizer<br>TfidfVectorizer会根据指定的公式将文档中的词转换为概率表示。<br>class sklearn.feature_extraction.text.TfidfVectorizer()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1、实例化一个转换器类</span><br>transfer = TfidfVectorizer(stop_words=[<span class="hljs-string">&quot;一种&quot;</span>, <span class="hljs-string">&quot;所以&quot;</span>])<br><span class="hljs-comment"># 2、调用fit_transform</span><br>data_final = transfer.fit_transform(data_new)<br></code></pre></td></tr></table></figure><h4 id="5-特征预处理"><a href="#5-特征预处理" class="headerlink" title="5.特征预处理"></a>5.特征预处理</h4><p>当特征的单位或者大小相差较大，或者某特征的方差相比其他的特征要大出几个数量级时，容易影响目标结果，使得算法无法学习到其他特征，这时就要通过一些转换函数将特征数据转换称更加适合算法模型的特征数据。</p><ol><li><p>归一化<br> 通过对原始数据进行变换把数据映射到（默认[0,1]）之间。<br> 常用的方法是通过min-max方法对原始数据进行线性变换把数据映射到[0,1]之间，变换的函数为：<br> <img src="/2022/03/06/MachineLearn/4.png" alt="min-max"><br> 缺点：最大值与最小值会受到异常点的影响，这种方法的鲁棒性较差，知识和传统精确小数据场景<br> API:<br> scikit-learn.preprocessing中的类MinMaxScaler，将数据矩阵缩放到[0,1]之间<br> sklearn.preprocessing,MinMaxScaler(feature_range&#x3D;(0,1)..)</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1、获取数据</span><br>data = pd.read_csv(<span class="hljs-string">&quot;dating.txt&quot;</span>)<br>data = data.iloc[:, :<span class="hljs-number">3</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;data:\n&quot;</span>, data)<br><span class="hljs-comment"># 2、实例化一个转换器类</span><br>transfer = MinMaxScaler(feature_range=[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>feature_range定义了期望的结果范围<br><span class="hljs-comment"># 3、调用fit_transform</span><br>data_new = transfer.fit_transform(data)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;data_new:\n&quot;</span>, data_new)<br></code></pre></td></tr></table></figure></li><li><p>标准化<br> 通过对原始数据进行变换把数据变换到均值为0，标准差为1<br> 处理方法：<br> <img src="/2022/03/06/MachineLearn/5.png" alt="标准化公式"><br> 其中μ是样本的均值，σ是样本的标准差，它们可以通过现有的样本进行估计，在已有的样本足够多的情况下比较稳定，适合嘈杂的数据场景.<br> API:<br> sklearn中提供了StandardScalar类实现列标准化:<br> sklearn.preprocessing.StandardScaler()<br> <img src="/2022/03/06/MachineLearn/6.png" alt="API"></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1、获取数据</span><br>    data = pd.read_csv(<span class="hljs-string">&quot;dating.txt&quot;</span>)<br>    data = data.iloc[:, :<span class="hljs-number">3</span>]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;data:\n&quot;</span>, data)<br><br>    <span class="hljs-comment"># 2、实例化一个转换器类</span><br>    transfer = StandardScaler()<br><br>    <span class="hljs-comment"># 3、调用fit_transform</span><br>    data_new = transfer.fit_transform(data)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;data_new:\n&quot;</span>, data_new)<br></code></pre></td></tr></table></figure></li><li><p>降维<br>在某些限定条件下，降低随机变量（特征）个数，得到一组不相关主变量的过程。<br>我们在进行训练的时候，我们都是使用特征进行学习，如果特征本身存在问题或者特征之间相关性较强，对于算法学习预测会影响较大<br>降维两种方式：<br>特征选择<br>主成分分析</p></li></ol><h4 id="6-特征选择"><a href="#6-特征选择" class="headerlink" title="6.特征选择"></a>6.特征选择</h4><p>sklearn.feature_selection</p><p>数据中包含冗余或相关变量，特征选择旨在从原有特征中找出主要特征。<br>特征选择主要有两个功能：<br>（1）减少特征数量，降维，使模型泛化能力更强，减少过拟合<br>（2）增强特征和特征值之间的理解<br>降维本质上是从一个维度空间映射到另一个维度空间，特征的多少并没有减少，当然在映射的过程中特征值也会相应的变化。<br>对于通过特征选择来降维，有很多方法：</p><p>(1) Filter(过滤式):<br>    主要探究特征本身特点、特征与特征和目标值之间关联<br>    ·方差选择法：低方差特征过滤<br>    ·相关系数</p><ol><li><p>低方差特征过滤</p><p> 删除低方差的一些特征，VarianceThreshold 是特征选择中的一项基本方法。它会移除所有方差不满足阈值的特征。<br> sklearn.feature_selection.VarianceThreshold(threshold&#x3D;0.0)<br> <img src="/2022/03/06/MachineLearn/7.png" alt="VarianceThreshold"></p></li><li><p>相关系数<br>皮尔逊相关系数：反映变量之间相关关系密切程度的统计指标<br>特点：<br><img src="/2022/03/06/MachineLearn/8.png" alt="相关系数"><br>API:<br>from scipy.stats import pearsonr</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算某两个变量之间的相关系数</span><br>    r1 = pearsonr(data[<span class="hljs-string">&quot;pe_ratio&quot;</span>], data[<span class="hljs-string">&quot;pb_ratio&quot;</span>])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;相关系数：\n&quot;</span>, r1)<br>    r2 = pearsonr(data[<span class="hljs-string">&#x27;revenue&#x27;</span>], data[<span class="hljs-string">&#x27;total_expense&#x27;</span>])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;revenue与total_expense之间的相关性：\n&quot;</span>, r2)<br></code></pre></td></tr></table></figure><p>(2) Embedded(嵌入式):<br>    VarianceThreshold<br>    ·算法自动选择特征（特征与目标是之间的关联）<br>    ·正则化、决策树<br>    ·深度学习：卷积</p><p>(3) Wrapper(包裹式)</p><h4 id="7-主成分分析PCA"><a href="#7-主成分分析PCA" class="headerlink" title="7.主成分分析PCA"></a>7.主成分分析PCA</h4><p>高维数据转换为低维数据的过程可能会舍弃原有数据创造新的变量。<br>PCA的作用便是将数据维数压缩，尽可能降低原数据的维数，损失少量信息。<br>应用：回归分析或者聚类分析中。</p><p>API:<br>sklearn.decomposition.PCA(in_components&#x3D;None)</p><p><img src="/2022/03/06/MachineLearn/9.png" alt="PCA"><br>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">data = [[<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], [<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>], [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>]]<br><br><span class="hljs-comment"># 1、实例化一个转换器类</span><br>transfer = PCA(n_components=<span class="hljs-number">0.95</span>)<br><span class="hljs-comment">#参数是降到几个特征</span><br><span class="hljs-comment"># 2、调用fit_transform</span><br>data_new = transfer.fit_transform(data)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;data_new:\n&quot;</span>, data_new)<br></code></pre></td></tr></table></figure><p><img src="/2022/03/06/MachineLearn/10.png" alt="思维导图"><br><img src="/2022/03/06/MachineLearn/11.png" alt="思维导图"></p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>Linear regression<br>线性回归是利用回归方程对一个或多个自变量（特征值）和因变量（目标值）之间关系进行建模的一种分析方式。<br>通用公式：<img src="/2022/03/06/MachineLearn/12.png" alt="公式"><br>线性关系一定是线性模型<br>线性模型不一定是线性关系</p><p>缺点：不能解决拟合问题</p><h3 id="线性回归API"><a href="#线性回归API" class="headerlink" title="线性回归API"></a>线性回归API</h3><p>普通最小二乘线性回归:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br>reg = LinearRegression()<br><span class="hljs-comment">#使用X作为训练数据拟合模型，y作为X的类别值</span><br>reg.fit(X,y,sample_weight = <span class="hljs-literal">None</span>)<br><span class="hljs-comment">#预测提供的数据对应的结果</span><br>reg.predict(X)  <br><span class="hljs-comment">#表示回归系数w=(w1,w2....)</span><br>reg.coef_ <br></code></pre></td></tr></table></figure><p>通过使用SGD最小化正则化经验损失拟合线性模型。<br>SGD代表随机梯度下降(Stochastic gradient descent)：每次对每个样本估计损失的梯度，并且沿着递减强度调度（aka学习速率）的路径更新模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model.SGDRegressor<br>reg=SGDRegressor(alpha=<span class="hljs-number">0.0001</span>, max_iter=<span class="hljs-number">1000</span>)<br><span class="hljs-comment">#参数代表学习率，迭代次数</span><br>reg.fit(x_train.y_train)<br></code></pre></td></tr></table></figure><p><img src="/2022/03/06/MachineLearn/15.png" alt="线性回归API"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="损失和优化原理"><a href="#损失和优化原理" class="headerlink" title="损失和优化原理"></a>损失和优化原理</h3><p>对于线性回归模型，将模型与数据点之间的距离差之和做为衡量匹配好坏的标准，误差越小,匹配程度越大。<br>损失函数（最小二乘法）：<img src="/2022/03/06/MachineLearn/13.png" alt="损失函数"><br>现在我们要是模型的损失函数最小，则有两种方法：</p><ol><li><p>梯度下降算法<br>梯度下降（Gradient Descent）是一个用来求函数最小值的算法，你可以用它来最小化任何代价函数，不只是线性回归中的代价函数。</p><p> 思想：开始时我们随机选择一个参数的组合，计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。我们持续这么做直到到到一个局部最小值，因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值，选择不同的初始参数组合，可能会找到不同的局部最小值。</p><p> 想象一下你正站立在山的这一点上，站立在你想象的公园这座红色山上，在梯度下降算法中，我们要做的就是旋转360度，看看我们的周围，并问自己要在某个方向上，用小碎步尽快下山。这些小碎步需要朝什么方向？如果我们站在山坡上的这一点，你看一下周围，你会发现最佳的下山方向，你再看看周围，然后再一次想想，我应该从什么方向迈着小碎步下山？然后你按照自己的判断又迈出一步，重复上面的步骤，从这个新的点，你环顾四周，并决定从什么方向将会最快下山，然后又迈进了一小步，并依此类推，直到你接近局部最低点的位置。<br> <img src="/2022/03/06/MachineLearn/16.png" alt="公式"></p><p> 梯度下降算法也有很多种：<br> <img src="/2022/03/06/MachineLearn/18.png" alt="公式"></p></li><li><p>正规方程<br>梯度下降法计算参数最优解，过程是对代价函数的每个参数求偏导，通过迭代算法一步步更新，直到收敛到全局最小值，从而得到最优参数。<br>正规方程是一次性求得最优解。<br>思想：对于一个简单函数，对参数求导，将其值置为0，就得到参数的值。<br>公式：<img src="/2022/03/06/MachineLearn/13.png" alt="正规方程"></p></li><li><p>正规方程与梯度下降法的比较</p></li></ol><table><thead><tr><th>梯度下降</th><th>正规方程</th></tr></thead><tbody><tr><td>需要选择学习率</td><td>不需要</td></tr><tr><td>需要多次迭代</td><td>一次运算得出</td></tr><tr><td>当特征数量大时也能较好适用</td><td>需要计算公式，如果特征数量n较大则运算代价大</td></tr><tr><td>适用于各种类型的模型</td><td>只适用于线性模型，不适合逻辑回归模型等其他模型</td></tr><tr><td>总结：取决于特征向量的个数，数量小于10000时，选择正规方程；大于10000，考虑梯度下降或其他算法。</td><td></td></tr></tbody></table><h2 id="回归性能评估"><a href="#回归性能评估" class="headerlink" title="回归性能评估"></a>回归性能评估</h2><p>均方误差(Mean Squared Error)MSE<br><img src="/2022/03/06/MachineLearn/17.png" alt="公式"><br>sklearn.metrics.mean_squared_error(y_true,y_pred)</p><h2 id="过拟合欠拟合"><a href="#过拟合欠拟合" class="headerlink" title="过拟合欠拟合"></a>过拟合欠拟合</h2><p>过拟合：过拟合是指我们设计的模型过于紧密或精确的匹配了某特定数据，使得模型缺少泛化能力，而无法有效处理其他的、或未观测的数据的现象。<br>欠拟合：欠拟合的概念恰恰与过拟合相反；它是指相对于数据而言，我们的预测模型过于简单，无法有效反应数据的特征规律，因此也缺少了泛化能力。</p><p>解决方法:正则化</p><h2 id="正则化-regularization"><a href="#正则化-regularization" class="headerlink" title="正则化(regularization)"></a>正则化(regularization)</h2><p>正则化（Regularization）是一个可以防止机器学习算法过度拟合数据集的概念。<br>过拟合一般都是拟合模型的参数次项过大，正则化便是事先让这些高次项的系数接近于0，从而达到好的拟合效果。<br>通过在损失函数中引入惩罚项（Penalizing term）来实现这一点，该惩罚项为复杂曲线指定了更高的惩罚</p><ol><li>L2正则化:<br>损失函数+λ惩罚项  （λ称为正则化参数，如果选择的正则化参数过大，则会把所有的参数都最小化了造成欠拟合。）<br>它通过使高次项的参数接近于0来削弱某个特征的影响。<br><img src="/2022/03/06/MachineLearn/19.png" alt="L2"><br>正则化力度越大，权重系数会越小<br>正则化力度越小，权重系数会越大</li><li>L1正则化：<br>它通过使高次项的参数直接为0来削弱某个特征的影响。</li></ol><h2 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h2><p>岭回归就是带L2正则化的线性回归，具有L2正则化的线性最小二乘法。<br>岭回归API:<br>sklearn.linear_model.Ridge</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Ridge<br>clf = Ridge(alpha=<span class="hljs-number">1.0</span>)<br></code></pre></td></tr></table></figure><p><img src="/2022/03/06/MachineLearn/20.png" alt="岭回归"></p><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><h2 id="模型保存与加载"><a href="#模型保存与加载" class="headerlink" title="模型保存与加载"></a>模型保存与加载</h2><h2 id="无监督学习-K-means"><a href="#无监督学习-K-means" class="headerlink" title="无监督学习 K-means"></a>无监督学习 K-means</h2><h2 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h2><h3 id="1-支持向量机简介"><a href="#1-支持向量机简介" class="headerlink" title="1. 支持向量机简介"></a>1. 支持向量机简介</h3><p>支持向量机是由Vapnik经过多年的统计学习理论研究提出的一种能够较好的解决线性不可分问题的监督式学习算法。起初，支持向量机主要应用于模式识别和一些分类问题，在后来随着不敏感损失函数的引入衍生出了支持向量回归机，使得支持向量机在函数的回归和预测领域起到广泛的应用。<br>它能够执行线性或分线性分类、回归等任务，适用于中小型复杂数据集的分类。<br>supported vector machine，简单来讲就是寻找到一个超平面使样本分成两类，并使间隔最大。<br><img src="/2022/03/06/MachineLearn/23.png" alt=" "></p><h3 id="2-超平面最大间隔介绍"><a href="#2-超平面最大间隔介绍" class="headerlink" title="2. 超平面最大间隔介绍"></a>2. 超平面最大间隔介绍</h3><p><img src="/2022/03/06/MachineLearn/21.png" alt=" "></p><h3 id="3-硬间隔和软间隔"><a href="#3-硬间隔和软间隔" class="headerlink" title="3. 硬间隔和软间隔"></a>3. 硬间隔和软间隔</h3><p><img src="/2022/03/06/MachineLearn/22.png" alt=" "></p><h3 id="4-SVM算法原理"><a href="#4-SVM算法原理" class="headerlink" title="4. SVM算法原理"></a>4. SVM算法原理</h3><p>线性模型问题：<br>如果现在又这样一个数据集，其中有正样本，也有负样本，分别由源泉和X号来表示，可以看到这个数据集是线性可分的，存在一条直线把正负样本分开。我们把这条直线叫做一个决策边界，决策边界会有很多个，如下图所示两种，右图相比左图从直观上看是要比左图的分开效果是要差的，对于支持向量机，它将会选择左图，因为看起来是更稳健的决策界，这条决策边界有更大的距离，这个距离叫做间隔(margin,对应图中的d)。因此支持向量机有时被称为大间距分类器.</p><ol><li><p>推导目标函数<br> <img src="/2022/03/06/MachineLearn/27.png" alt=" "><br> <img src="/2022/03/06/MachineLearn/28.png" alt=" "></p></li><li><p>SVM损失函数<br><img src="/2022/03/06/MachineLearn/29.png" alt=" "></p></li></ol><h3 id="5-核函数"><a href="#5-核函数" class="headerlink" title="5. 核函数"></a>5. 核函数</h3><p>核函数就是将原始的输入空间映射到新的特征空间。从而使得原本线性不可分的样本可能在核空间可分。<br>核函数的作用就是一个从低维空间到高维空间的映射，而这个映射可以把低维空间中线性不可分的两类点变成线性可分的。<br>   <img src="/2022/03/06/MachineLearn/30.png" alt=" "></p><p>常见核函数：<br>   <img src="/2022/03/06/MachineLearn/30.png" alt=" "><br>   <img src="/2022/03/06/MachineLearn/31.png" alt=" "><br>   <img src="/2022/03/06/MachineLearn/32.png" alt=" "></p><h3 id="6-SVM回归"><a href="#6-SVM回归" class="headerlink" title="6. SVM回归"></a>6. SVM回归</h3><p>让尽可能多的实例位于预测线上，同时限制间隔违例<br>   <img src="/2022/03/06/MachineLearn/33.png" alt=" "></p><h3 id="7-SVM-API"><a href="#7-SVM-API" class="headerlink" title="7. SVM API"></a>7. SVM API</h3><p>SVM方法既可以用于分类，也可以用于回归和异常值检测。</p><p>SVM有很好的鲁棒性，对未知数据拥有很强的泛化能力，特别是在数据量较少的情况下，相较其他传统机器学习算法具有更优的性能</p><p>SVM模型流程：</p><ol><li>对样本数据进行归一化</li><li>应用核函数对样本进行映射</li><li>用cross-validation和grid-search对超参数进行优选</li><li>用最优参数训练得到模型</li><li>测试<br><img src="/2022/03/06/MachineLearn/34.png" alt=" "></li></ol><h4 id="SVC"><a href="#SVC" class="headerlink" title="SVC"></a>SVC</h4><p><img src="/2022/03/06/MachineLearn/35.png" alt=" "><br><img src="/2022/03/06/MachineLearn/36.png" alt=" "></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> svm<br>X=[[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]<br>y=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>ss=svm.SVC()<br>ss.fit(X,y)<br>ss.predict([[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]])<br></code></pre></td></tr></table></figure><h3 id="8-SVM总结"><a href="#8-SVM总结" class="headerlink" title="8. SVM总结"></a>8. SVM总结</h3><p><img src="/2022/03/06/MachineLearn/37.png" alt=" "></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【PythohCrawler】</title>
    <link href="/2022/03/03/PythohCrawler/"/>
    <url>/2022/03/03/PythohCrawler/</url>
    
    <content type="html"><![CDATA[<h1 id="Python爬虫"><a href="#Python爬虫" class="headerlink" title="Python爬虫"></a>Python爬虫</h1><h2 id="爬虫简介"><a href="#爬虫简介" class="headerlink" title="爬虫简介"></a>爬虫简介</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>网络爬虫就是模拟客户端发送网络请求，获取响应数据，一种按照一定的规则，自动的抓取万维网信息的程序或脚本</p><h3 id="2-爬虫的应用："><a href="#2-爬虫的应用：" class="headerlink" title="2.爬虫的应用："></a>2.爬虫的应用：</h3><p>随着网络的迅速发展，万维网成为大量信息的载体，如何有效地提取并利用这些信息成为一个巨大的挑战，因此爬虫应运而生，它不仅能够被使用在搜索引擎领域，而且在大数据分析，以及商业领域都得到了大规模的应用。</p><ol><li>数据分析<br>在数据分析领域，网络爬虫通常是搜集海量数据的必备工具。对于数据分析师而言，要进行数据分析，首先要有数据源，而学习爬虫，就可以获取更多的数据源。在采集过程中，数据分析师可以按照自己目的去采集更有价值的数据，而过滤掉那些无效的数据。</li><li>商业领域<br>对于企业而言，及时地获取市场动态、产品信息至关重要。企业可以通过第三方平台购买数据，比如贵阳大数据交易所、数据堂等，当然如果贵公司有一个爬虫工程师的话，就可通过爬虫的方式取得想要的信息。</li></ol><h3 id="3-编写爬虫的流程："><a href="#3-编写爬虫的流程：" class="headerlink" title="3.编写爬虫的流程："></a>3.编写爬虫的流程：</h3><ol><li>先由 urllib 模块的 request 方法打开 URL 得到网页 HTML 对象。</li><li>使用浏览器打开网页源代码分析网页结构以及元素节点。</li><li>通过 Beautiful Soup 或则正则表达式提取数据。</li><li>存储数据到本地磁盘或数据库。</li></ol><hr><h2 id="request库"><a href="#request库" class="headerlink" title="request库"></a>request库</h2><p>Python 内置了 requests 模块，该模块主要用来发送 HTTP 请求并获取响应数据。Requests的主要功能及用途是用作发送网络请求，根据对方服务器的要求不同，可使用GET、POST和PUT等方式进行请求。并且可以对请求头进行伪装、使用代理访问等。</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#导入 requests 包</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-comment">#发送请求</span><br>req = requests.get(<span class="hljs-string">&#x27;https://www.baidu.com/&#x27;</span>)<br><span class="hljs-built_in">print</span>(req.status_code)<br><span class="hljs-comment"># 响应状态码</span><br><span class="hljs-built_in">print</span>(req.text)<br><span class="hljs-comment"># 响应的文本内容</span><br><span class="hljs-built_in">print</span>(req.content)<br><span class="hljs-comment"># 响应的二进制内容</span><br><span class="hljs-built_in">print</span>(response.content.decode())<br><span class="hljs-comment"># 把二进制数据转换字符串</span><br><span class="hljs-built_in">print</span>(req.cookies)<br><span class="hljs-comment"># 响应的cookies</span><br><span class="hljs-built_in">print</span>(req.encoding)<br><span class="hljs-comment"># 响应的编码</span><br><span class="hljs-built_in">print</span>(req.headers)<br><span class="hljs-comment"># 响应的头部信息</span><br><span class="hljs-built_in">print</span>(req.url)<br><span class="hljs-comment"># 响应的网址</span><br><span class="hljs-built_in">print</span>(req.history)<br></code></pre></td></tr></table></figure><h4 id="requests-方法"><a href="#requests-方法" class="headerlink" title="requests 方法"></a>requests 方法</h4><p>requests 方法如下表：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>delete(url, args)</td><td>发送 DELETE 请求到指定 url</td></tr><tr><td>get(url, params, args)</td><td>发送 GET 请求到指定 url</td></tr><tr><td>head(url, args)</td><td>发送 HEAD 请求到指定 url</td></tr><tr><td>patch(url, data, args)</td><td>发送 PATCH 请求到指定 url</td></tr><tr><td>post(url, data, json, args)</td><td>发送 POST 请求到指定 url</td></tr><tr><td>put(url, data, args)</td><td>发送 PUT 请求到指定 url</td></tr><tr><td>request(method, url, args)</td><td>向指定的 url 发送指定的请求方法</td></tr></tbody></table><hr><h2 id="BeautifulSoup库"><a href="#BeautifulSoup库" class="headerlink" title="BeautifulSoup库"></a>BeautifulSoup库</h2><p>Beautiful Soup是一个从HTML或XML中提取数据的python库。<br>它提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。</p><h4 id="Beautiful-Soup库的基本使用"><a href="#Beautiful-Soup库的基本使用" class="headerlink" title="Beautiful Soup库的基本使用"></a>Beautiful Soup库的基本使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">html = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span><br><span class="hljs-string">&lt;body&gt;</span><br><span class="hljs-string">&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;</span><br><span class="hljs-string">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span><br><span class="hljs-string">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span><br><span class="hljs-string">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span><br><span class="hljs-string">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span><br><span class="hljs-string">and they lived at the bottom of a well.&lt;/p&gt;</span><br><span class="hljs-string">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Eastmount/article/details/109497225?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-109497225-blog-99338957.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-109497225-blog-99338957.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=12">详细</a></p><ol><li><p>对象介绍与创建：<br>对象：<br>代表要解析整个文档树，它支持遍历文档树和搜索文档树中描述的大部分的方法。<br>创建beautifulsoup对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> beautifulsoup<br>soup=beautifulsoup=(html,<span class="hljs-string">&#x27;lxml&#x27;</span>) <span class="hljs-comment">#后面的lxml是指定的解析器</span><br></code></pre></td></tr></table></figure></li><li><p>获取网页标签信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">soup.title<br>soup.head<br>soup.a<br></code></pre></td></tr></table></figure></li><li><p>搜索文档树<br>对象的find方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">find(<span class="hljs-variable language_">self</span>,name=Mone,attrs=&#123;&#125;,recursive=<span class="hljs-literal">True</span>,text=<span class="hljs-literal">None</span>,**kwargs) <br>参数:<br>    name:标签名<br>    attrs:属性字典<br>    recursibe:是否递归循环查找<br>    text:根据文本内容查找<br>    可以指定上述参数的值来查找内容<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。<br>正则表达式的大致匹配过程是：</p><ol><li>依次拿出表达式和文本中的字符比较，</li><li>如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。</li><li>如果表达式中有量词或边界，这个过程会稍微有一些不同。</li></ol><h4 id="正则表达式的语法规则"><a href="#正则表达式的语法规则" class="headerlink" title="正则表达式的语法规则"></a>正则表达式的语法规则</h4><p><img src="/2022/03/03/PythohCrawler/1.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#导入正则模块</span><br><span class="hljs-keyword">import</span> re<br><span class="hljs-comment">#字符匹配</span><br>rs=re.findall(<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-string">&#x27;awgduywagydgaiabc&#x27;</span>)<br>rs=re.findall(<span class="hljs-string">&#x27;a.c&#x27;</span>,)<br>语法：<br><span class="hljs-number">1.</span>匹配除换行符以外的所有字符<br><span class="hljs-number">2.</span>\d匹配[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]的数字<br><span class="hljs-number">3.</span>\w匹配字母数字——和中文<br><span class="hljs-number">4.</span>*前面的一个匹配模式出现<span class="hljs-number">0</span>次或多次<br><span class="hljs-number">5.</span>+前面的一个匹配模式出现<span class="hljs-number">1</span>次或多次<br><span class="hljs-number">6.</span>？前面的一个匹配模式出现<span class="hljs-number">0</span>或<span class="hljs-number">1</span>次<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">re.findall(pattern,string,flags=<span class="hljs-number">0</span>)<br>作用：扫描整个string字符串，返回所有与pattern匹配的列表<br>参数：<br>pattern:正则表达式<br>string:从那个字符串中查找<br>flags:指定 匹配模式<br>返回string中与pattern匹配的结果列表<br></code></pre></td></tr></table></figure><p>特点：<br>如果正则表达式中没有（）则返回整个正则匹配的列表<br>如果正则表达式中有（），则返回（）中匹配的内容列表，小括号两边东西都是负责确定提取数据的所在位置</p><h4 id="反斜杠问题"><a href="#反斜杠问题" class="headerlink" title="反斜杠问题"></a>反斜杠问题</h4><p>与大多数编程语言相同，正则表达式里使用”\”作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符”\”，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\\”：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。</p><hr><h2 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h2><p>用于json和python数据之间的相互转换</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>json.dumps</td><td>将 Python 对象编码成 JSON 字符串</td></tr><tr><td>json.loads</td><td>将已编码的 JSON 字符串解码为 Python 对象</td></tr></tbody></table><h4 id="将-Python-对象编码成-JSON-字符串"><a href="#将-Python-对象编码成-JSON-字符串" class="headerlink" title="将 Python 对象编码成 JSON 字符串"></a>将 Python 对象编码成 JSON 字符串</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>data = [ &#123; <span class="hljs-string">&#x27;a&#x27;</span> : <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span> : <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span> : <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span> : <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span> : <span class="hljs-number">5</span> &#125; ]<br>data2 = json.dumps(data)<br><span class="hljs-built_in">print</span>(data2) <br><br>以上代码执行结果为：<br>[&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;c&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;e&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&quot;d&quot;</span>: <span class="hljs-number">4</span>&#125;]<br></code></pre></td></tr></table></figure><h4 id="把json格式文件转换为Python类型数据"><a href="#把json格式文件转换为Python类型数据" class="headerlink" title="把json格式文件转换为Python类型数据"></a>把json格式文件转换为Python类型数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><br>jsonData = <span class="hljs-string">&#x27;&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5&#125;&#x27;</span>;<br><br>text = json.loads(jsonData)<br><span class="hljs-built_in">print</span>(text)<br>以上代码执行结果为：<br>&#123;<span class="hljs-string">u&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">u&#x27;c&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">u&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">u&#x27;e&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">u&#x27;d&#x27;</span>: <span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="爬取丁香园疫情数据"><a href="#爬取丁香园疫情数据" class="headerlink" title="爬取丁香园疫情数据"></a>爬取丁香园疫情数据</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#1.导入模块</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> beautifulsoup<br><span class="hljs-keyword">import</span> re<br><span class="hljs-comment">#2.发送请求，获取响应</span><br>response = requests.get(<span class="hljs-string">&#x27;https://ncov.dxy.cn/ncovh5/view/pneumonia&#x27;</span>)<br><span class="hljs-comment">#3.从响应中获取数据</span><br>homepage = response.content.decode()<br><span class="hljs-comment">#4.使用beautifulsoup提取疫情数据</span><br>soup=beautifulsopu(homepage,<span class="hljs-string">&#x27;lxml&#x27;</span>)<br>script=soup.find(<span class="hljs-built_in">id</span>=<span class="hljs-string">&#x27;&#x27;</span>)<br>text=script.text<br><br><span class="hljs-comment">#5.使用正则表达式，提取Json字符串</span><br>匹配括号中的内容<br>json_str=re.findall(<span class="hljs-string">r&#x27;\[.+\]d&#x27;</span>,text)[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment">#6.json格式字符串转换为Python类型</span><br>last_day_cor=json.loads(json_str) <span class="hljs-comment">#python列表，里面是字典</span><br><br><span class="hljs-comment">#7.以json格式保存</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    json.dump(last_day,fp)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Git】</title>
    <link href="/2022/01/16/Git/"/>
    <url>/2022/01/16/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="git是什么"><a href="#git是什么" class="headerlink" title="git是什么"></a>git是什么</h2><p>  git是分布式版本控制系统<br>特点：解决多人同时开发的代码问题，也可以找回历史代码。<br>原理：一台充当服务器的电脑或者Github网站，其他人可以从这个服务器仓库中拉取一份代码到自己的电脑上，用户可以自行在自己电脑上对代码操作，<br>操作结束后可以向服务器或者Github推送提交，也可以从仓库中拉取别人的提交。</p><h2 id="git基本操作"><a href="#git基本操作" class="headerlink" title="git基本操作"></a>git基本操作</h2><h3 id="1-创建版本库"><a href="#1-创建版本库" class="headerlink" title="1. 创建版本库"></a>1. 创建版本库</h3><p>在所选目录下使用：git init ，即可对该目录下的文件使用git管理。<br>执行命令后会在目录下生成一个 .git 隐藏文件夹，代表成功。<br><img src="/2022/01/16/Git/Git_1.png"></p><h3 id="2-版本创建与回退"><a href="#2-版本创建与回退" class="headerlink" title="2. 版本创建与回退"></a>2. 版本创建与回退</h3><ul><li>加入我在在所选目录下创建一个文件code.text,并在里面写了first内容</li><li>使用下两条命令可以创建一个版本<br><code> git add code.txt    (git add命令可将该文件添加到暂存区)</code><br><code>  git commit -m &#39;版本1&#39; (git commit用来创建版本 &#39;&#39;内容表示对版本的说明)  </code><br><img src="/2022/01/16/Git/Git_2.png"></li><li>使用<code>git log</code> 可以查看版本记录,commit后面代表版本的序列号.<br><img src="/2022/01/16/Git/Git_3.png"></li><li>此时我又在code.txt中输入了second内容，并继续采用add和commit命令创建了版本2，那么此时我对于code.txt就有了两个版本<br>每个版本保存了当时创建版本时文件所存储的信息（可以理解为文件记录点），后一版本只记录较上一版本我修改了什么，并不是完整的保存整个文件。<br><img src="/2022/01/16/Git/Git_4.png"></li><li>现在若想要回到前一个版本1，可以使用：<br><code>git reset --hard HEAD^</code><br>其中HEAD表示当前最新版本，HEAD^表示当前版本的前一个版本，HAED^^表示当前版本的前两个版本。<br>也可以使用HEAD<del>1表示当前版本前一版本，HEAD</del>100表示回到前100。<br>执行命令后code.txt将回到版本1时的状态,只有个first，版本2也没有被删除.<br><img src="/2022/01/16/Git/Git_5.png"></li><li>现在若想再回到版本2，则可以：<br><code>git reset --hard 版本序列号</code><br><img src="/2022/01/16/Git/Git_6.png"></li><li>如果不小心把终端关闭了，无法再看到之前版本2的序列号则可以执行：<br><code>git reflog</code><br><img src="/2022/01/16/Git/Git_7.png"></li><li>查看当前git状态,看看工作区中有没有什么尚未暂存以备提交的变更或者新增加的未跟踪（未add commit的）文件。<br><code>git status</code></li></ul><h3 id="3-工作区和暂存区"><a href="#3-工作区和暂存区" class="headerlink" title="3. 工作区和暂存区"></a>3. 工作区和暂存区</h3><p> 工作区：我们刚才创立的目录git_test就叫工作区。<br> 版本库：.git隐藏目录就是版本库,git的版本库中有很多东西，最重要的时暂存区，还有git为我们自动创建的第一个分支Master，以及指向master的一份指针HEAD。git add就是将修改放到暂存区中。<br> git commit就是往master分支上提交更改。可以简单的理解为，需要提交的文件修改通通放到暂存区中，然后一次性提交暂存区的所有修改。<br> <font color="red">我创立的文件在工作区，此时我执行add，该文件存放到了暂存区，我对该文件又进行了修改并commit了，此时修改存到了版本库中。</font><br> <img src="/2022/01/16/Git/Git_8.png"></p><h3 id="4-管理修改"><a href="#4-管理修改" class="headerlink" title="4. 管理修改"></a>4. 管理修改</h3><p>git管理的文件修改，<font color="red">它只会提交暂存区的修改来创建版本</font>。</p><h3 id="5-撤销修改"><a href="#5-撤销修改" class="headerlink" title="5. 撤销修改"></a>5. 撤销修改</h3><p><code>git checkout -- 文件名</code><br>此命令可以用来丢弃工作区的改动。<br><code>git reset HEAD filename</code><br>此命令可以把暂存区的修改撤销掉，重新放回工作区。<br><img src="/2022/01/16/Git/Git_9.png"></p><h3 id="6-对比文件的不同"><a href="#6-对比文件的不同" class="headerlink" title="6. 对比文件的不同"></a>6. 对比文件的不同</h3><ul><li>对比工作区和某个版本中文件的不同。<br><code>git diff HEAD -- filename</code><br>比如我在工作区中往code.txt中新加入了different,执行命令后则可以看到刚才的修改与某个版本相比增加了什么。<br><img src="/2022/01/16/Git/Git_10.png"></li><li>对比两个版本中文件的不同。<br><code>git diff HEAD HEAD^ -- filename</code><br>filename代表要对比两个版本中的哪一个文件。<br><img src="/2022/01/16/Git/Git_11.png"></li></ul><h3 id="7-删除文件"><a href="#7-删除文件" class="headerlink" title="7. 删除文件"></a>7. 删除文件</h3><p><code>git rm filename</code><br>从版本中删除某文件,并再次commit创建删除记录。  </p><h2 id="git操作命令集合"><a href="#git操作命令集合" class="headerlink" title="git操作命令集合"></a>git操作命令集合</h2><figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus">单人操作:<br><span class="hljs-number">1</span><span class="hljs-selector-class">.sudo</span> apt-get intall git ,安装git ,并创建git密码<br><span class="hljs-number">2</span><span class="hljs-selector-class">.git</span>, 查看安装结果,有提示则证明安装成功<br><span class="hljs-number">3</span><span class="hljs-selector-class">.git</span> init , 创建本地仓库<br><span class="hljs-number">4</span><span class="hljs-selector-class">.git</span> config user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&#x27;张三&#x27;</span>, 配置git提交的用户名<br><span class="hljs-number">5</span><span class="hljs-selector-class">.git</span> config user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&#x27;123@qq.com&#x27;</span>, 配置git提交的邮箱<br><span class="hljs-number">6</span><span class="hljs-selector-class">.git</span> status, 查看工作区的文件状态<br><span class="hljs-number">7</span><span class="hljs-selector-class">.git</span> add 文件名, 添加指定文件名到暂存区<br><span class="hljs-number">8</span><span class="hljs-selector-class">.git</span> add . 添加所有的改动文件到暂存区<br><span class="hljs-number">9</span><span class="hljs-selector-class">.git</span> commit -m <span class="hljs-string">&#x27;版本信息描述&#x27;</span>,  添加当前版本说明<br><span class="hljs-number">10</span><span class="hljs-selector-class">.git</span> commit -am <span class="hljs-string">&#x27;版本信息&#x27;</span>, 直接添加到暂存区并提交到git仓库<br><span class="hljs-number">11</span><span class="hljs-selector-class">.git</span> log, 查看详情历史版本<br><span class="hljs-number">12</span><span class="hljs-selector-class">.git</span> reflog, 查看简单历史版本<br><span class="hljs-number">13</span><span class="hljs-selector-class">.git</span> reset <span class="hljs-attr">--hard</span> HEAD^ 回退到上个版本<br><span class="hljs-number">14</span><span class="hljs-selector-class">.git</span> reset <span class="hljs-attr">--hard</span> HEAD~<span class="hljs-number">1</span>回到上个版本<br><span class="hljs-number">15</span><span class="hljs-selector-class">.git</span> reset <span class="hljs-attr">--hard</span> 版本号,  跳转到指定的版本号<br><span class="hljs-number">16</span><span class="hljs-selector-class">.git</span> checkout 文件名,  撤销指定文件的修改,工作区<br><span class="hljs-number">17</span><span class="hljs-selector-class">.git</span> reset HEAD 文件名,  撤销暂存区的代码<br><span class="hljs-number">19</span><span class="hljs-selector-class">.git</span> diff HEAD HEAD^ -- 文件名,对比版本库<br><span class="hljs-number">20</span><span class="hljs-selector-class">.rm</span> 文件名, 删除文件,通过下面<span class="hljs-number">21</span>行命令撤销<br><span class="hljs-number">21</span><span class="hljs-selector-class">.git</span> checkout -- 文件名, 撤销删除<br><span class="hljs-number">22</span><span class="hljs-selector-class">.git</span> rm 文件名, 删除本地文件, 并提交,通过下面的<span class="hljs-number">23</span>行命令撤销<br><span class="hljs-number">23</span>. git reset <span class="hljs-attr">--hard</span> HEAD^,撤销<br><br>多人开发:<br><span class="hljs-number">23</span><span class="hljs-selector-class">.git</span> clone 地址, 克隆远程的代码到本地<br><span class="hljs-number">24</span><span class="hljs-selector-class">.git</span> push, 推送到远程仓库<br><span class="hljs-number">25</span><span class="hljs-selector-class">.git</span> config <span class="hljs-attr">--global</span>  credential<span class="hljs-selector-class">.helper</span> cache 十五分钟有效期<br><span class="hljs-number">26</span><span class="hljs-selector-class">.git</span> config  credential<span class="hljs-selector-class">.helper</span> <span class="hljs-string">&#x27;cache --timeout==3600&#x27;</span> 一个小时有效期<br><span class="hljs-number">27</span><span class="hljs-selector-class">.git</span> config <span class="hljs-attr">--global</span> credential<span class="hljs-selector-class">.helper</span> store 长期有效<br><span class="hljs-number">28</span><span class="hljs-selector-class">.git</span> pull ,拉取远程代码到本地目录<br><br><br>标签<br><span class="hljs-number">29</span><span class="hljs-selector-class">.git</span> tag -<span class="hljs-selector-tag">a</span> 标签名 -m <span class="hljs-string">&#x27;标签描述v1.0&#x27;</span>,  本地标签<br><span class="hljs-number">30</span><span class="hljs-selector-class">.git</span> push origin 标签名, 将本地标签版本推送到远程端<br><span class="hljs-number">31</span><span class="hljs-selector-class">.git</span> tag -d 标签名,  删除本地标签<br><span class="hljs-number">32</span><span class="hljs-selector-class">.git</span> push origin <span class="hljs-attr">--delete</span> tag 标签名, 删除远端的标签名<br><br><br>分支<br><span class="hljs-number">33</span><span class="hljs-selector-class">.git</span> branch, 查看当前分支<br><span class="hljs-number">34</span><span class="hljs-selector-class">.git</span> checkout -<span class="hljs-selector-tag">b</span> 分支名, 切换到指定分支<br><span class="hljs-number">35</span><span class="hljs-selector-class">.git</span> push -u origin 分支名,  推送本地分支跟踪远程分支<br><span class="hljs-number">36</span><span class="hljs-selector-class">.git</span> checkout master/dev 切换到master主分支/子分支<br><span class="hljs-number">37</span><span class="hljs-selector-class">.git</span> merge 分支A, 合并指定分支A到主分支中<br><br><br><br></code></pre></td></tr></table></figure><hr><h2 id="git分支管理"><a href="#git分支管理" class="headerlink" title="git分支管理"></a>git分支管理</h2><h3 id="1-概念及作用"><a href="#1-概念及作用" class="headerlink" title="1. 概念及作用"></a>1. 概念及作用</h3><p><img src="/2022/01/16/Git/Git_12.png"><br><img src="/2022/01/16/Git/Git_13.png"></p><h3 id="2-创建与合并分支"><a href="#2-创建与合并分支" class="headerlink" title="2. 创建与合并分支"></a>2. 创建与合并分支</h3><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="(1)概念："></a>(1)概念：</h4><p>  git会将我们之前每次提交的版本串成一条时间线，这条时间线就是一个分支。在git中，这个分支叫做主分支，即master分支。<br>  对于HEAD 严格来说不是指向提交，而是指向master，再由master指向提交。<br>  <img src="/2022/01/16/Git/14.png"><br>  <img src="/2022/01/16/Git/15.png"><br>  <img src="/2022/01/16/Git/16.png"><br>  <img src="/2022/01/16/Git/17.png"><br>  <img src="/2022/01/16/Git/18.png"></p><h4 id="2-分支的基本操作"><a href="#2-分支的基本操作" class="headerlink" title="(2)分支的基本操作"></a>(2)分支的基本操作</h4><ul><li>(1)查看当前有几个分支并看到在哪个分支下工作<br>  <code>git branch</code> </li><li>(2)创建一个新分支dev并切换到上面工作<br>  <code>git checkout -b dev</code><br>  此时HEAD指向dev,后续的版本操作都是在dev下操作，master将不会移动，依然指在原先位置。<br><img src="/2022/01/16/Git/19.png"></li><li>(3)将新分支合并到master上<br>  <code>git merge dev</code><br>  这条命令使用的是快速合并，也就是直接把master指向dev的当前提交，所以合并速度非常快。<br>  合并完成后，就可以放心的执行下列命令删除dev分支。<br>  <code>git branch -d dev</code><h4 id="3-分支操作命令集合"><a href="#3-分支操作命令集合" class="headerlink" title="(3)分支操作命令集合"></a>(3)分支操作命令集合</h4><img src="/2022/01/16/Git/20.png"></li></ul><h3 id="3-解决冲突"><a href="#3-解决冲突" class="headerlink" title="3. 解决冲突"></a>3. 解决冲突</h3><p>  当master和dev都对某一文件进行了修改并提交了版本，这时候合并就会冲突。<br>  解决方法是在master中对文件进行手动修改并提交新版本，此时的情况就会变成下图样子：<br>  <img src="/2022/01/16/Git/21.png"><br>  此时便可以删除dev。</p><h3 id="4-分支管理策略"><a href="#4-分支管理策略" class="headerlink" title="4. 分支管理策略"></a>4. 分支管理策略</h3><p>  通常，合并分支时，如果可能，git会用fast forward模式进行快速合并，但此时不能执行快速合并且合并时没有冲突，这时候合并之后会做一次新的提交(包含合并前两个分支的修改内容)。<br>  提交时会出现弹窗让你输入提交说明信息。<br>  合并结束后可以删除dev。</p><h3 id="5-Bug分支"><a href="#5-Bug分支" class="headerlink" title="5.Bug分支"></a>5.Bug分支</h3><p>  当我们遇到Bug需要修复时，可以为bug建一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。<br>  在实际工作中，我们在做手头工作但是接到了修复Bug的任务，不得不停下来当前任务，此时可以用 <code>git stash</code>将当前的工作现场存储起来以便修复Bug后继续手头工作.<br>  修复Bug过程：</p><ol><li>首先要确定在哪个分支上修复Bug,假如在master上，就从master创建临时分支。 </li><li>在临时分支中修复bug，并进行提交。</li><li>切换回master，采用禁止快速合并策略进行合并<br><code>git merge --no-ff -m &#39;说明信息&#39; 要合并的分支</code></li><li>删除Bug临时分支，可以回到原先环境干活，采用<br>   <code>git stash list</code> 看看保存过的工作现场。<br>采用<code>git stash pop</code>便可以回到现场.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数据可视化】国内新冠疫情数据可视化大屏</title>
    <link href="/2021/06/22/COVID-Visualization/"/>
    <url>/2021/06/22/COVID-Visualization/</url>
    
    <content type="html"><![CDATA[<p>本项目是采用Flask框架配合ehcharts做的疫情数据可视化大屏</p><h3 id="项目展示"><a href="#项目展示" class="headerlink" title="项目展示"></a>项目展示</h3><p>本项目将平台分为五大模块：<br>(1) 标题模块：存放项目标题，并实时显示当前时间。<br>(2) 疫情数据模块：以金色字体展示当前的疫情状况的文本数据，分为累计确诊、累计疑<br>似、累计治愈、累计死亡四个部分。<br>(3) 疫情地图模块：展示中国疫情数据地图，选取蓝色作为反应色彩，以颜色深度反应疫<br>情状况，颜色越深就代表该区域感染的人数越多，疫情形势越险峻。鼠标划过区域将显示该<br>区域累计确诊人数,并有鼠标左击地图下钻功能以看到市级疫情地图数据。<br>(4) 疫情趋势模块：展示从疫情开始到现在每天的累计趋势和新增趋势，在累计趋势中包<br>含累计确诊、现有疑似、累计治愈、累计死亡曲线，新增趋势中包含新增确诊和新增死亡曲<br>线。<br>(5) 国外疫情数据及 top10 模块：通过柱状图展示国外疫情现状，以六大洲为主数据，采<br>用与中国地图同样的左键单击下钻方式来详细的展示各个州内国家的数据。通过扇形图展示<br>国外确诊病例国家 top10，一目了然的了解国外目前疫情发展最为严重的国家。</p><p><img src="/2021/06/22/COVID-Visualization/2.png" alt="项目效果图"><br><a href="https://github.com/MeoPig/COVID-19-Visual-platform">项目GitHub链接</a></p><h3 id="疫情数据获取"><a href="#疫情数据获取" class="headerlink" title="疫情数据获取"></a>疫情数据获取</h3><p>本项目使用的数据来自丁香园全球新冠疫情地图网站和腾讯新闻新型冠状病毒肺炎疫情实时追踪站。<br>先分析目标网页结构，通过 Python 的 request 库向页面发起请求，获取网页源码，通过 Beautifulsoup 库的 find 函数查找匹配疫情数据所在字符串，经<br>分析选取本项目所需要的数据有：国内各省市的确诊人数、疑似人数、死亡人数、治愈人数、新增确诊人数、新增疑似人数、日期以及国外各国的确诊人数。并将其转为 json 格式存储在文件中。再通过 Pymysql 库将 json 数据文件解析后批量存储到 Mysql 中，为方便查看管理操作数据集，使用 SQLyog来管理数据库。</p><h3 id="项目具体实现过程"><a href="#项目具体实现过程" class="headerlink" title="项目具体实现过程"></a>项目具体实现过程</h3><p>项目结构目录：<br><img src="/2021/06/22/COVID-Visualization/1.png" alt="结构"></p><p>项目中名叫utils的python文件定义了许多函数用来专门的从数据库中读取数据，在这个文件中我借助pymysql库与数据库建立连接，并建立了一个游标对象来执行SQL语句和获取查询结果。<br>项目名叫app的python文件为各个功能模块单独定义了页面路由以及视图函数，通过函数调用utils中的函数，将得到的数据通过jsonify函数将获取到的数据转换为JSON格式并封装为HTTP响应对象，然后将HTTP响应对象返回给客户端，当客户端请求我定义的页面路由里，将会收到从服务器返回的JSON格式的数据。<br>在js的文件夹中，单独写了一个controller.js文件用来提供给各个模块以通过ajax向服务器发起get请求，获取到json数据后便可以交给echarts来实现数据的可视化。<br>Ajax技术还能页面上异步更新数据，并根据数据的变化动态更新页面上的图表和文字内容。</p><p>在本地开发完项目后就将项目部署到云服务器上了，在Linux下配置好项目运行所需环境，配置好Nginx 和 Gunicorn之后就可以启动项目。</p><hr><h3 id="复试中可能会问到的点"><a href="#复试中可能会问到的点" class="headerlink" title="复试中可能会问到的点"></a>复试中可能会问到的点</h3><h4 id="1-什么是Flaks框架？它与Django框架有什么区别？"><a href="#1-什么是Flaks框架？它与Django框架有什么区别？" class="headerlink" title="1.什么是Flaks框架？它与Django框架有什么区别？"></a>1.什么是Flaks框架？它与Django框架有什么区别？</h4><p>Django 和 Flask 都是常用的 Python Web 框架，它们都可以用于构建 Web 应用程序，但在某些方面有所不同。<br>Django 是一个全功能的 Web 框架，它提供了大量的内置组件，包括 ORM、模板引擎、路由、表单处理、认证、管理后台等，能够快速构建出大型 Web 应用程序。<br>Flask 是一个微型 Web 框架，它的设计目标是简单、轻量级和灵活，只提供了基本的 Web 应用程序开发功能。Flask 允许开发者通过插件和扩展来扩展其功能，因此可以根据需要构建出特定的应用程序。Flask 的开发者通常采用简单而直接的设计哲学，因此可以更快地启动并运行应用程序。<br>总的来说，Django 更适合开发大型 Web 应用程序，提供了大量的内置功能和组件，可以快速构建出功能丰富的 Web 应用程序。Flask 更适合小型或中型 Web 应用程序，因为它更灵活、更轻量级，可以根据需要进行定制和扩展。</p><h4 id="2-你在服务器部署项目中提到了Nignx和Gunicorn，介绍一下这两个？"><a href="#2-你在服务器部署项目中提到了Nignx和Gunicorn，介绍一下这两个？" class="headerlink" title="2. 你在服务器部署项目中提到了Nignx和Gunicorn，介绍一下这两个？"></a>2. 你在服务器部署项目中提到了Nignx和Gunicorn，介绍一下这两个？</h4><p>Nginx 和 Gunicorn 都是常用的 Web 服务器软件，它们通常用于部署 Python Web 应用程序。<br>Nginx 是一个高性能的反向代理服务器，常用于处理静态资源和负载均衡。在 Flask 应用程序部署过程中，Nginx 通常会作为反向代理服务器，接收客户端的请求，将请求转发给 Gunicorn 作为应用服务器进行处理，并将处理结果返回给客户端。<br>Gunicorn（Green Unicorn）是一个 Python WSGI (Web Server Gateway Interface) HTTP 服务器，用于部署 Python Web 应用程序。它支持多进程模式，可以同时处理多个客户端请求，并提供了高效的性能和稳定性。在 Flask 应用程序部署过程中，Gunicorn 会作为应用服务器运行 Flask 应用程序，处理客户端请求。<br>综合来看，Nginx 和 Gunicorn 的组合可以提高 Flask 应用程序的性能和可靠性，同时提供更好的用户体验。</p><h4 id="3-你在项目中提到了ajax，介绍一下它的用途功能？"><a href="#3-你在项目中提到了ajax，介绍一下它的用途功能？" class="headerlink" title="3. 你在项目中提到了ajax，介绍一下它的用途功能？"></a>3. 你在项目中提到了ajax，介绍一下它的用途功能？</h4><p>ajax 全名 async javascript and XML(异步JavaScript和XML)，是前后台交互的能⼒，一种用于创建快速动态网页的技术，也就是我们客户端给服务端发送消息的⼯具，它可以：</p><ol><li>不刷新页面更新网页</li><li>在页面加载后从服务器请求数据</li><li>在页面加载后从服务器接收数据</li><li>在后台向服务器发送数据</li></ol><h4 id="4-介绍一下echarts？"><a href="#4-介绍一下echarts？" class="headerlink" title="4.介绍一下echarts？"></a>4.介绍一下echarts？</h4><p>ECharts是一个基于JavaScript的开源可视化库，用于构建交互式的数据可视化图表和图形。ECharts提供了多种类型的图表，包括线性图、散点图、饼图、地图等，并且支持动画效果和数据区间选择、缩放等交互操作。ECharts可以轻松地在Web页面、移动端和桌面应用程序中使用，并且可以与React、Vue等前端框架进行集成。<br>使用过程：<br>初始化实例：echarts.init(document.getElementById());<br>配置图表：通过配置项来设置图表的属性，包括图表类型、数据、样式、交互等。<br>渲染图表：myChart.setOption(数据)，将配置好的图表实例传递给 ECharts 的渲染方法，将图表渲染到页面上。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数据可视化】学校生源分布可视化</title>
    <link href="/2021/05/15/MapdrilldownandLinkeage/"/>
    <url>/2021/05/15/MapdrilldownandLinkeage/</url>
    
    <content type="html"><![CDATA[<h1 id="本项目采用Flask框架基于echarts实现省市县地图三级下钻以及图表联动操作"><a href="#本项目采用Flask框架基于echarts实现省市县地图三级下钻以及图表联动操作" class="headerlink" title="本项目采用Flask框架基于echarts实现省市县地图三级下钻以及图表联动操作"></a>本项目采用Flask框架基于echarts实现省市县地图三级下钻以及图表联动操作</h1><p>运行软件：Pycharm<br>运行环境：python3.8<br>第三方包:   flask,pymysql,utils</p><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果:"></a>实现效果:</h2><p><img src="https://img-blog.csdnimg.cn/20210705202628543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MjA2OTM0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>省市县三级下钻展示：</strong><br>市级：<br><img src="https://img-blog.csdnimg.cn/20210705202708111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MjA2OTM0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>县级：<br><img src="https://img-blog.csdnimg.cn/20210705202718979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MjA2OTM0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>扇形图做总控制台，柱状图以及表格跟随联动：</strong><br>如点击扇形图里面的陕西，柱状图跟表格则会切换为陕西的数据<br><img src="https://img-blog.csdnimg.cn/20210705202902996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MjA2OTM0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="本项目已开源到Github"><a href="#本项目已开源到Github" class="headerlink" title="本项目已开源到Github"></a>本项目已开源到Github</h2><p>链接：<a href="https://github.com/MeoPig/MapdrilldownAndLinkage">MapdrildownAndLinkage</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【MarkDown】</title>
    <link href="/2021/02/15/MarkDown/"/>
    <url>/2021/02/15/MarkDown/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h1><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题</span><br><span class="hljs-section">## 二级标题</span><br><span class="hljs-section">### 三级标题</span><br><span class="hljs-section">#### 四级标题</span><br><span class="hljs-section">##### 五级标题</span><br><span class="hljs-section">###### 六级标题</span><br></code></pre></td></tr></table></figure><h2 id="2-换行"><a href="#2-换行" class="headerlink" title="2.换行"></a>2.换行</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">直接在一句话后敲两个空格  <br>两句话之间加一个空行  <br>如果你在编辑的时候，想让一行文字在显示的时候换行，就在中间加<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-字体"><a href="#3-字体" class="headerlink" title="3.字体"></a>3.字体</h2><p>星号与下划线都可以<br/><br><code>*斜体*</code>  <em>斜体</em><br/><br><code>_斜体_</code><em>斜体</em><br/><br><code>**粗体**</code><strong>粗体</strong><br/><br><code>__粗体__</code><strong>粗体</strong><br/><br><code>***粗斜体***</code><em><strong>粗斜体</strong></em><br/><br><code>___粗斜体___</code><em><strong>粗斜体</strong></em><br/></p><h2 id="4-链接"><a href="#4-链接" class="headerlink" title="4.链接"></a>4.链接</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[链接名称]</span>(链接地址)<br>&lt;链接地址&gt;<br></code></pre></td></tr></table></figure><p>example:<br><code>[百度](www.baidu.com)</code><br><a href="www.baidu.com">百度</a></p><h2 id="5-插入图片"><a href="#5-插入图片" class="headerlink" title="5.插入图片"></a>5.插入图片</h2><p><code>![图片描述](图片地址，本地链接或者URL地址)</code><br>example:<br><code> ![baidu](https://www.baidu.com/img/flexible/logo/pc/result.png)</code><br><img src="https://www.baidu.com/img/flexible/logo/pc/result.png" alt="baidu"></p><h2 id="6-列表"><a href="#6-列表" class="headerlink" title="6.列表"></a>6.列表</h2><ul><li>无序列表: 使用*或+或-，再加一个空格作为列表的标记</li><li>有序列表: 使用数字并加上.号，再加一个空格作为列表的标记<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 无序列表 1<br><span class="hljs-bullet">+</span> 无序列表 2<br><span class="hljs-bullet">-</span> 无序列表 3<br><br><span class="hljs-bullet">1.</span> 有序列表 1<br><span class="hljs-bullet">2.</span> 有序列表 2<br><span class="hljs-bullet">3.</span> 有序列表 3<br></code></pre></td></tr></table></figure>效果：  </li><li>无序列表 1</li></ul><ul><li>无序列表 2</li></ul><ul><li>无序列表 3</li></ul><ol><li>有序列表 1</li><li>有序列表 2</li><li>有序列表 3</li></ol><h2 id="7-分割线与删除线与下划线"><a href="#7-分割线与删除线与下划线" class="headerlink" title="7.分割线与删除线与下划线"></a>7.分割线与删除线与下划线</h2><p>注意使用分割线时应在上面空一行，否则会导致上行字体增大。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">分割线：</span><br><span class="hljs-section">---</span><br><span class="hljs-bullet">***</span><br><span class="hljs-bullet"></span><span class="hljs-bullet">- </span>- -<br><span class="hljs-bullet">* </span>* * <br><br>删除线：<br>~~被删除的文字~~<br><br>下划线：<br>&lt;u&gt;下划线&lt;/u&gt;<br><br></code></pre></td></tr></table></figure><ul><li>分割线效果：</li></ul><hr><hr><hr><hr><ul><li>删除线效果：<br><del>被删除的文字</del>  </li><li>下划线效果：<br><u>下划线</u></li></ul><h2 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8.代码块"></a>8.代码块</h2><ul><li>一行内采用单反引号,如<code>`Hello`</code> 效果：<code>Hello</code>   </li><li>一整块采用三个单反引号，同时在前一个反引号后写入代码的语言<br>如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">```cpp<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-表格"><a href="#9-表格" class="headerlink" title="9.表格"></a>9.表格</h2><p>表格使用|来分割不同的单元格，使用-来分隔表头和其他行</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:-</span>：将表头及单元格内容左对齐<br>-<span class="hljs-symbol">:</span>：将表头及单元格内容右对齐<br><span class="hljs-symbol">:-</span><span class="hljs-symbol">:</span>：将表头及单元格内容居中<br></code></pre></td></tr></table></figure><table><thead><tr><th>项目</th><th align="right">价格</th><th align="center">数量</th></tr></thead><tbody><tr><td>计算机</td><td align="right">$1600</td><td align="center">5</td></tr><tr><td>手机</td><td align="right">$12</td><td align="center">12</td></tr><tr><td>管线</td><td align="right">$1</td><td align="center">234</td></tr></tbody></table><h2 id="10-特殊符号"><a href="#10-特殊符号" class="headerlink" title="10.特殊符号"></a>10.特殊符号</h2><p>对于Markdown中的语法符号，前面加反斜线\即可以显示符号本身。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MarkDown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
