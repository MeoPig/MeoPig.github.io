

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="操作系统 第一章 OS概述  *1.1 概念和功能概念：操作系统是指控制和管理整个计算机系统硬件和软件资源的最基本的系统软件。 功能：（计算机系统自下而上分为：硬件、操作系统、应用程序、用户）     向上提供接口（用户：命令接口，编程员：程序接口）；     对下层功能的拓展；     对系统资源的管理（处理机、存储器、文件、设备）。  *1.2 特征并发性：指两个或多个事件在同一时间间隔内发生">
<meta property="og:type" content="article">
<meta property="og:title" content="【计算机考研复试】操作系统">
<meta property="og:url" content="http://example.com/2022/03/10/operatingsystem/index.html">
<meta property="og:site_name" content="MeoPig">
<meta property="og:description" content="操作系统 第一章 OS概述  *1.1 概念和功能概念：操作系统是指控制和管理整个计算机系统硬件和软件资源的最基本的系统软件。 功能：（计算机系统自下而上分为：硬件、操作系统、应用程序、用户）     向上提供接口（用户：命令接口，编程员：程序接口）；     对下层功能的拓展；     对系统资源的管理（处理机、存储器、文件、设备）。  *1.2 特征并发性：指两个或多个事件在同一时间间隔内发生">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-10T08:43:17.000Z">
<meta property="article:modified_time" content="2022-03-19T08:17:47.144Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="【计算机考研复试】">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>【计算机考研复试】操作系统 - MeoPig</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="MeoPig" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>MeoPig</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/3.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="【计算机考研复试】操作系统">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-10 16:43" pubdate>
        2022年3月10日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.4k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      71 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">【计算机考研复试】操作系统</h1>
            
            <div class="markdown-body">
              <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><hr>
<h2 id="第一章-OS概述"><a href="#第一章-OS概述" class="headerlink" title="第一章 OS概述  "></a>第一章 OS概述  </h2><h4 id="1-1-概念和功能"><a href="#1-1-概念和功能" class="headerlink" title="*1.1 概念和功能"></a>*1.1 概念和功能</h4><div class="code-wrapper"><pre><code class="hljs">概念：操作系统是指控制和管理整个计算机系统硬件和软件资源的最基本的系统软件。
功能：（计算机系统自下而上分为：硬件、操作系统、应用程序、用户）
    向上提供接口（用户：命令接口，编程员：程序接口）；
    对下层功能的拓展；
    对系统资源的管理（处理机、存储器、文件、设备）。
</code></pre></div>
<h4 id="1-2-特征"><a href="#1-2-特征" class="headerlink" title="*1.2 特征"></a>*1.2 特征</h4><div class="code-wrapper"><pre><code class="hljs">并发性：指两个或多个事件在同一时间间隔内发生；（并行性：在同一时刻…）
共享性：系统中的资源可供内存中多个并发执行的进程共同使用；
虚拟性：把一个物理上的实体变成若干个逻辑上的对应物；
异步性：进程的执行并不是一气呵成的，而是以不可预知的速度向前推进.
</code></pre></div>
<h4 id="1-3-运行机制"><a href="#1-3-运行机制" class="headerlink" title="1.3 运行机制"></a>1.3 运行机制</h4><div class="code-wrapper"><pre><code class="hljs">CPU的两种状态
用户态（目态）：不可以执行特权指令
内核态（管态）
CPU“变态”的唯一条件： 中断/异常
实现“变态”的机制：通过硬件实现
</code></pre></div>
<h4 id="1-4-中断和异常"><a href="#1-4-中断和异常" class="headerlink" title="1.4 中断和异常"></a>1.4 中断和异常</h4><div class="code-wrapper"><pre><code class="hljs">中断（外中断）：指来自CPU执行指令以外的事件发生；（如设备发出的I/O结束中断）
异常（内中断、trap）：指源自CPU执行指令内部的事件.（如地址越界，算术溢出）
</code></pre></div>
<h4 id="1-5系统调用"><a href="#1-5系统调用" class="headerlink" title="1.5系统调用"></a>1.5系统调用</h4><div class="code-wrapper"><pre><code class="hljs">概念：指用户在程序中调用OS所提供的一些功能。
目的：用户必须通过调用系统调用才能操作系统资源（OS代为完成），以保证系统稳定性和安全性。
</code></pre></div>
<h4 id="1-6处理器为什么要区分核心态和用户态？在什么情况下进行两种方式的切换？"><a href="#1-6处理器为什么要区分核心态和用户态？在什么情况下进行两种方式的切换？" class="headerlink" title="1.6处理器为什么要区分核心态和用户态？在什么情况下进行两种方式的切换？"></a>1.6处理器为什么要区分核心态和用户态？在什么情况下进行两种方式的切换？</h4><div class="code-wrapper"><pre><code class="hljs">区分执行态的主要目的时保护系统程序。用户态到核心态的转换发生在中断产生时，而核心态到用户态的转换则发生在中断返回用户程序时。
</code></pre></div>
<hr>
<hr>
<h2 id="第2章-进程管理"><a href="#第2章-进程管理" class="headerlink" title="第2章 进程管理"></a>第2章 进程管理</h2><h4 id="2-1-进程的概述"><a href="#2-1-进程的概述" class="headerlink" title="2.1 进程的概述"></a>2.1 进程的概述</h4><div class="code-wrapper"><pre><code class="hljs">概念：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
组成：
    PCB：进程存在的唯一标志
    程序段
    相关数据段
引入进程的目的：
为了更好地使多道程序并发执行，提高资源利用率和系统吞吐量。
特征：
    动态性：进程是程序的一次执行过程。进程是动态的，程序是静态的；
    并发性：多个进程同时存在于内存中，能在一段时间内同时运行。引入进程的目的就是为了使程序能够并发运行；
    独立性：进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。而程序不能作为一个独立的单位参与运行
    异步性：异步性导致执行结果的不可再现性，因此OS中必须配置进程同步机制；
    结构性：每一个进程都配置一个PCB对其进行描述。
</code></pre></div>
<h4 id="2-2-进程的通信"><a href="#2-2-进程的通信" class="headerlink" title="2.2 进程的通信"></a>2.2 进程的通信</h4><div class="code-wrapper"><pre><code class="hljs">方式：
低级通信方式：PV操作
高级通信方式：共享存储、消息传递、管道通信
</code></pre></div>
<h4 id="2-3-线程"><a href="#2-3-线程" class="headerlink" title="2.3 线程"></a>2.3 线程</h4><div class="code-wrapper"><pre><code class="hljs">概念：线程时进程中的一个实体，是被系统独立调度和分派的基本单位。 
引入线程的目的：
为了减小程序在并发执行的过程中所付出的时空开销，提高操作系统的并发性能。
</code></pre></div>
<h4 id="2-4-线程与进程的比较"><a href="#2-4-线程与进程的比较" class="headerlink" title="2.4 线程与进程的比较"></a>2.4 线程与进程的比较</h4><table>
<thead>
<tr>
<th>比较</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>调度</td>
<td>仅是资源分配的基本单位</td>
<td>独立调度、分派的基本单位</td>
</tr>
<tr>
<td>并发性</td>
<td>仅进程间并发</td>
<td>进程间、线程间并发</td>
</tr>
<tr>
<td>拥有资源</td>
<td>资源拥有的基本单位</td>
<td>基本上不拥有资源</td>
</tr>
<tr>
<td>系统开销</td>
<td>创建、撤销、切换开销大</td>
<td>仅保存少量寄存器内容，开销小</td>
</tr>
</tbody></table>
<div class="code-wrapper"><pre><code class="hljs">线程的实现方式：
    用户级线程：线程的管理工作都由应用程序完成，应用程序通过使用线程库实现多线程程序；
    内核级线程：线程的所有工作由内核完成。
</code></pre></div>
<h4 id="2-5-处理及调度？"><a href="#2-5-处理及调度？" class="headerlink" title="2.5 处理及调度？"></a>2.5 处理及调度？</h4><div class="code-wrapper"><pre><code class="hljs">处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法选择一个进程，并将处理机分配给它运行。
调度方式：非抢占式、抢占式
调度的性能准则：
    CPU利用率：应该尽量使CPU处于“忙”状态；
    系统吞吐量：表示单位时间内系统完成作业的数量；
    周转时间：作业从提交到完成的时间；
    等待时间：处于等处理机状态的时间；
    响应时间：从用户提交到系统首次响应。
调度算法：
    FCFS、SJF、优先级、高响应比、时间片轮转、多级反馈队列
</code></pre></div>
<h4 id="2-6-进程同步与互斥"><a href="#2-6-进程同步与互斥" class="headerlink" title="2.6 进程同步与互斥"></a>2.6 进程同步与互斥</h4><div class="code-wrapper"><pre><code class="hljs">同步（直接制约关系）：指为完成某种任务而简历的两个或多个进程，这些进程因需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。
互斥（间接制约关系）：当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一个进程才允许去访问此临界资源。
临界资源：一次仅允许一个进程使用的资源，必须互斥访问；
临界区：每个进程中，访问临界资源的那段代码。（进入区、临界区、退出区、剩余区）
实现进程互斥的方法
软件实现方法：在进入区设置并检查一些标志来标明是否有进程在临界区中，若有，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。
硬件实现方法：
中断屏蔽法：使用“开/关中断”指令，禁止一切中断的发生，只适合单CPU、OS内核进程；
硬件指令法（TSL/Swap）：原子操作，适合多处理机。
</code></pre></div>
<h4 id="2-7-举例解释一下同步和互斥"><a href="#2-7-举例解释一下同步和互斥" class="headerlink" title="*2.7 举例解释一下同步和互斥"></a>*2.7 举例解释一下同步和互斥</h4><div class="code-wrapper"><pre><code class="hljs">同步表现为直接制约，如管道通信，一个进程写，一个进程读，它们是相互制约的。
互斥表现为间接制约，比如多个进程同时请求打印机（无SPOOLing技术时）
</code></pre></div>
<h4 id="2-8-原语？"><a href="#2-8-原语？" class="headerlink" title="2.8 原语？"></a>2.8 原语？</h4><div class="code-wrapper"><pre><code class="hljs">原语是指完成某种功能且不被分割、不被中断执行的操作序列。
</code></pre></div>
<h4 id="2-9-管程？"><a href="#2-9-管程？" class="headerlink" title="*2.9 管程？"></a>*2.9 管程？</h4><div class="code-wrapper"><pre><code class="hljs">管程是由一组局部变量、对局部变量进行操作的一组过程和对局部变量进行初始化的语句序列组成。引入的原因是因为P/V操作太过分散，对它的维护很麻烦且容易造成死锁。
组成：
    局部于管程的数据结构；
    对数据结构进行操作的函数过程；
    数据结构的初始化。
基本特性：
局部于管程的数据只能被局部于管程的过程所访问；
一个进程只能通过调用管程内的过程才能进入管程访问共享数据；
每次仅允许一个进程在管程内执行某个内部过程。
</code></pre></div>
<h4 id="2-10-死锁？"><a href="#2-10-死锁？" class="headerlink" title="*2.10 死锁？"></a>*2.10 死锁？</h4><div class="code-wrapper"><pre><code class="hljs">定义：
    多个进程因竞争资源而造成的一种互相等待的局面，若无外力作用，这些进程将无法向前推进。
产生的原因：
    系统资源的竞争、进程推进顺序不当。
产生的必要条件：
    互斥条件、不可剥夺条件、请求并保持条件、循环等待条件
死锁的处理策略：
    死锁预防：设置某些限制条件，破坏死锁的4个必要条件中的一个或几个，以防止死锁的发生；
    死锁避免：在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁；
    死锁的检测与解除：通过系统的检测机构及时地检测出死锁的发生，然后采取某些措施解除死锁。
死锁预防：
    破坏互斥条件：使系统资源都能共享；
    （这种方法不太可行）
    破坏不剥夺条件：当进程已保持了一些不可剥夺资源且又申请新的资源而得不到满足时，它必须释放已经保持的所有资源，待需要时重新申请；
    （这种方法实现复杂，会增加系统开销，降低系统吞吐量）
    破坏请求并保持状态：进程在运行前一次性申请完他所需要的全部资源；
    （这种方法实现简单，但是会严重浪费系统资源，还会导致饥饿现象）
    破坏循环等待状态：给系统中的资源编号，规定每个进程必须按照编号递增的顺序请求资源，同类资源一次申请完；
    （这种方法限制了新类型设备的增加，给用户编程带来麻烦）
避免死锁
概念：进程可以动态地申请资源，但系统在进行资源分配前，需要先计算此资源分配的安全性，若此次分配不会导致系统进入不安全状态则分配，否则让进程等待。

安全序列：
    指系统能按照某种顺序为每个进程分配其所需的资源，直到满足每个进程对资源的最大需求，使得每个进程都可以顺利完成。
（并非所有的不安全状态都是死锁状态，反之，只要系统处于安全状态，就不会进入死锁状态）
死锁的检测与解除
资源分配图
死锁定理：死锁的条件是当且仅当资源分配图是不可完全简化的。
死锁解除
</code></pre></div>
<h4 id="2-11-什么是安全状态？当系统不安全时就是系统进入了死锁状态吗？"><a href="#2-11-什么是安全状态？当系统不安全时就是系统进入了死锁状态吗？" class="headerlink" title="*2.11 什么是安全状态？当系统不安全时就是系统进入了死锁状态吗？"></a>*2.11 什么是安全状态？当系统不安全时就是系统进入了死锁状态吗？</h4><div class="code-wrapper"><pre><code class="hljs">安全状态是指系统按照某种进程顺序，为进程分配资源，使得每个进程都能获取所需的最大资源，并顺利完成。
不是，但是死锁状态一定是不安全状态。
</code></pre></div>
<h4 id="2-12-简述银行家算法？"><a href="#2-12-简述银行家算法？" class="headerlink" title="2.12 简述银行家算法？"></a>2.12 简述银行家算法？</h4><div class="code-wrapper"><pre><code class="hljs">银行家算法是最著名的死锁避免算法，其思想是：避免系统进入不安全状态。在每次进行资源分配时，它首先检查系统是否有足够的资源满足要求，若有则先进行分配，并对分配后的新状态进行安全性检查。若新状态安全，则正式分配上述资源，否则拒绝分配上述资源。这样，它保证系统始终处于安全状态，从而避免了死锁现象的发生。
</code></pre></div>
<h4 id="2-13-简述进程和程序的区别。"><a href="#2-13-简述进程和程序的区别。" class="headerlink" title="*2.13 简述进程和程序的区别。"></a>*2.13 简述进程和程序的区别。</h4><div class="code-wrapper"><pre><code class="hljs">进程和程序是既有联系又有区别。
主要区别：
1.程序是指令的有序集合，其本身没有任何运行的含义，它是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个动态概念。
2.程序的存在是永久的，而进程则是有生命的，它因创建而产生，因调度而执行，因得不到资源而暂停，因撤销而消亡。
3.程序仅是指令的有序集合。而进程则是由程序、数据和进程控制块组成。
</code></pre></div>
<hr>
<hr>
<h2 id="第三章-内存管理"><a href="#第三章-内存管理" class="headerlink" title="第三章 内存管理"></a>第三章 内存管理</h2><h4 id="3-1-内存管理的功能"><a href="#3-1-内存管理的功能" class="headerlink" title="3.1 内存管理的功能"></a>3.1 内存管理的功能</h4><div class="code-wrapper"><pre><code class="hljs">内存的分配与回收
地址转换
内存空间的扩充
存储保护
</code></pre></div>
<h4 id="3-2-进程运行的基本原理"><a href="#3-2-进程运行的基本原理" class="headerlink" title="3.2 进程运行的基本原理"></a>3.2 进程运行的基本原理</h4><div class="code-wrapper"><pre><code class="hljs">从写程序到程序运行
生成源代码文件
    编译：编译程序将源代码编译成若干的目标模块；
    链接：由链接程序将目标模块与所需库函数链接成一个完整的装入模块；
    装入：由装入程序将装入模块装入内存运行。
三种链接方式（生成逻辑地址）：
    静态链接：在 程序运行之前链接成一个可执行程序；
    装入时动态链接：在装入内存时，采用 边装入边链接的方法；
    运行时动态链接：在程序 运行时需要该目标模块再链接。便于修改和更新，有利于目标模块的共享。
三种装入方式（生成物理地址）：
    绝对装入：在单道程序环境下，编译时知道程序的实际存储位置，则编译时产生绝对地址的目标代码，即 逻辑地址与物理地址相同；
    可重定位装入（静态重定位）：在多道程序环境下，目标模块的起始地址通常是从0开始，装入时，将目标程序的逻辑地址 一次性换为物理地址；
    动态运行时装入（动态重定位）：程序可以可以在内存中发生移动，需要设置一个重定位寄存器，装入时，目标程序的逻辑地址 不需要立即转换为物理地址，可以需要的时候再换。
</code></pre></div>
<h4 id="3-3-内存扩充：覆盖与交换"><a href="#3-3-内存扩充：覆盖与交换" class="headerlink" title="3.3 内存扩充：覆盖与交换"></a>3.3 内存扩充：覆盖与交换</h4><div class="code-wrapper"><pre><code class="hljs">覆盖技术：
    基本思想：将用户空间分为一个固定区和若干个覆盖区。
    固定区：存放最活跃的程序段，程序运行时不会调入调出；
    覆盖区：不会被同时访问的程序段共享一个覆盖区，根据需要进行调入调出；
    特点：打破了必须将一个进程的全部信息装入内存后才能运行的限制。
交换技术：
    基本思想：（中级调度时采用）
    换出：内存紧张时，将处于等待状态的进程从内存调到辅存；
    换入：把准备好竞争CPU的进程从辅存移到内存中。
    特点：把磁盘空间分为文件区和交换区
二者区别：
覆盖技术常用于 同一个程序或进程中，而交换技术则在 不同进程或程序之间进行；
覆盖技术必须由程序员声明覆盖结构，使得对用户和程序员 不透明。
</code></pre></div>
<h4 id="3-4-连续内存分配"><a href="#3-4-连续内存分配" class="headerlink" title="3.4 连续内存分配"></a>3.4 连续内存分配</h4><div class="code-wrapper"><pre><code class="hljs">概念：为一个用户程序分配一个连续的内存空间。
三种方式：单一连续分配、固定分区分配、动态分区分配
单一连续分配：
    只支持单道程序，内存分为系统区和用户区；
    无外部碎片，有内部碎片；
    可以采用 覆盖交换技术。
固定分区分配：
    支持多道程序，内存分为若干固定分区；
    无外部碎片，有内部碎片；
    为分区建立一张 分区说明表，分区大小可以相等或不等。
动态分区分配：
    特点：
    支持多道程序，根据进程大小动态分区；
    无内部碎片，有外部碎片；
    外部碎片采用 “紧凑”技术得以解决：操作系统不时的对进程进行移动和整理，需要采用 动态重定位寄存器。
</code></pre></div>
<h4 id="3-5-4种动态分区分配算法："><a href="#3-5-4种动态分区分配算法：" class="headerlink" title="3.5 4种动态分区分配算法："></a>3.5 4种动态分区分配算法：</h4><div class="code-wrapper"><pre><code class="hljs">首次适应：地址递增，顺序查找；
最佳适应：容量递增，依次查找；
最坏适应：容量递减，依次查找；
邻近适应：在首次适应的基础上，按照从上次结束的位置进行依次查找。
</code></pre></div>
<h4 id="3-6-非连续分配管理"><a href="#3-6-非连续分配管理" class="headerlink" title="3.6 非连续分配管理"></a>3.6 非连续分配管理</h4><div class="code-wrapper"><pre><code class="hljs">概念：
为一个用户程序分配不连续的内存空间。
基本方法：分页存储管理、分段存储管理
分页存储管理
    分页的原理：把主存空间划分为大小相等且固定的块，作为主存的基本单位；每个进程也以块为单位划分，进程执行时，以块为单位申请内存空间。
基本地址变换机构
    具有快表的地址变换机构：先到高速缓冲寄存器中找，再去内存中的页表里找，减少了访存次数；
    两级页表：页表存放在内存中，若大量无用的页表存放在主存中会造成内存浪费，因此建立多级页表，其目的在于建立索引，以便不浪费主存空间去存储无用的页表项，也不用盲目的顺序式查找页表项。
分段存储管理
    分段的特点：将地址空间按程序自身逻辑分段；每个段在内存中占连续空间，各段可不相邻。
</code></pre></div>
<h4 id="3-7-分段和分页的主要区别："><a href="#3-7-分段和分页的主要区别：" class="headerlink" title="*3.7 分段和分页的主要区别："></a>*3.7 分段和分页的主要区别：</h4><div class="code-wrapper"><pre><code class="hljs">目的：分页的为了满足系统管理的需要，分段是为了满足用户的需要；
大小：页的大小是固定的，段的大小是不固定的；
维度：页的地址是一维的，段的地址是二维的；
碎片：分页有内部碎片无外部碎片，分段有外部碎片无内部碎片。
</code></pre></div>
<h4 id="3-8-虚拟内存、虚拟存储器？"><a href="#3-8-虚拟内存、虚拟存储器？" class="headerlink" title="3.8 虚拟内存、虚拟存储器？"></a>3.8 虚拟内存、虚拟存储器？</h4><div class="code-wrapper"><pre><code class="hljs">局部性原理：
    时间局部性：当前所访问的数据，很可能再次被访问；
    空间局部性：当前所访问的存储单元，其周围的存储单元很可能下次被访问。
虚拟存储器的定义和主要特性：
    定义：基于局部性原理，系统利用部分调用、请求调入、置换功能，好像为用户提供了一个比实际内存大得多的存储器；
    主要特性：
        多次性：作业无须一次调入，允许分多次调入内存；
        对换性：作业在运行过程中无须常驻内存，可以根据需要进行换入换出；
        虚拟性：从逻辑上扩充内存容量。
虚拟内存技术的实现：
    三种方式：请求分页存储管理、请求分段存储管理、请求段页式存储管理
    硬件支持：页表机制、缺页中断机构、地址变换机构
</code></pre></div>
<h4 id="3-9-请求分页管理方式"><a href="#3-9-请求分页管理方式" class="headerlink" title="3.9 请求分页管理方式"></a>3.9 请求分页管理方式</h4><div class="code-wrapper"><pre><code class="hljs">请求分页系统建立在基本分页系统的基础上，为了实现虚拟存储功能而增加了请求调页功能和页面置换功能。
页表机制：
    在基本分页系统的基础上增加了4个字段：
    状态位：用于指示该页是否已经调入内存；
    访问字段：用于记录本页在一段时间内被访问的次数，供置换算法参考；
    修改位：标记在调入内存后该页是否被修改过；
    外存地址：用于指出该页在外存上的地址，供调入页面时参考。
缺页中断机构：
    在请求分页系统中，当所要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。
地址变换机构：
    找到页表项要检查页面是否在内存中；若在，则修改页表项中的访问位，得出物理地址，若不在，请求调页，调入时，若内存不够，进行页面置换。
</code></pre></div>
<h4 id="3-11-试述缺页中断与一般中断有何区别？"><a href="#3-11-试述缺页中断与一般中断有何区别？" class="headerlink" title="*3.11 试述缺页中断与一般中断有何区别？"></a>*3.11 试述缺页中断与一般中断有何区别？</h4><div class="code-wrapper"><pre><code class="hljs">缺页中断的处理过程与一般中断相似。
主要区别：
1.在指令执行期间产生和处理中断信号。
2.一条指令在执行期间可能产生多次缺页中断。
</code></pre></div>
<h4 id="3-12-页面置换算法"><a href="#3-12-页面置换算法" class="headerlink" title="3.12 页面置换算法"></a>3.12 页面置换算法</h4><div class="code-wrapper"><pre><code class="hljs">最佳置换算法：淘汰的页面时未来最长时间不会被使用的；
先进先出算法：优先淘汰最先被调入的页面；
最近最久未使用算法：优先淘汰最近最长时间为被访问的页面；
时钟置换算法（最近未用算法）：循环扫描缓冲区，优先淘汰未使用过的页面。
改进的时钟算法：循环扫描缓冲区，若有未使用过的页面，则当然首先把它换出，若全部页面使用过，则当然优先把未修改过的页面换出。
</code></pre></div>
<h4 id="3-13-简述一下Clock置换算法"><a href="#3-13-简述一下Clock置换算法" class="headerlink" title="3.13 简述一下Clock置换算法"></a>3.13 简述一下Clock置换算法</h4><div class="code-wrapper"><pre><code class="hljs">该算法为每个页面设置一位访问位，将内存中的所有页面通过指针链成一个循环队列。由于该算法只有一位访问位，只能用它表示该页是否已经使用过，而置换时是将最近未使用过的页面换出去，所以把该算法称为最近未用算法。
选择页置换的过程：
1.当某页被访问时，其访问位置“1”；
2.在选择一页淘汰时，就检查其访问位，如果是“0”，就选择该页换出；若为“1”，则重新置为“0”，暂不换出该页；
3.在循环队列中检查下一个页面，直到访问到访问位为“0”的页面为止。
</code></pre></div>
<h4 id="3-14-页面分配策略"><a href="#3-14-页面分配策略" class="headerlink" title="3.14 页面分配策略"></a>3.14 页面分配策略</h4><div class="code-wrapper"><pre><code class="hljs">驻留集：请求分页存储管理中，给一个进程分配的物理页框的集合就是这个进程的驻留集。
页面分配策略：固定分区局部置换、可变分配全局置换、可变分区局部置换
抖动：刚换出的页面马上又要换入主存，或者反之。
    主要原因：某个进程频繁访问的页面数目高于可用的物理页框数目
工作集：在某段时间间隔内，进程要访问的页面集合。
</code></pre></div>
<hr>
<hr>
<h2 id="第4章-文件管理"><a href="#第4章-文件管理" class="headerlink" title="第4章 文件管理"></a>第4章 文件管理</h2><h4 id="4-1-文件管理的概述"><a href="#4-1-文件管理的概述" class="headerlink" title="4.1 文件管理的概述"></a>4.1 文件管理的概述</h4><div class="code-wrapper"><pre><code class="hljs">文件的定义：
一组有意义的信息集合，可以是文档、图片、程序等。在用户进行输入、输出时，以文件为基本单位。
文件的基本操作：
操作系统提供 系统调用对文件进行创建、读、写、重定位、删除和截断等操作。
</code></pre></div>
<h4 id="4-2-文件的逻辑结构"><a href="#4-2-文件的逻辑结构" class="headerlink" title="4.2 文件的逻辑结构"></a>4.2 文件的逻辑结构</h4><div class="code-wrapper"><pre><code class="hljs">文件的逻辑结构是从用户观点出发看到的文件的组织形式。
文件的物理结构是从实现观点出发看到的文件在外存上的存储组织形式。
无结构文件（流式文件）
有结构文件（有记录文件）：
    顺序文件
    索引文件
    索引顺序文件
    直接（散列）文件
</code></pre></div>
<h4 id="4-4-文件物理结构"><a href="#4-4-文件物理结构" class="headerlink" title="4.4 文件物理结构"></a>4.4 文件物理结构</h4><div class="code-wrapper"><pre><code class="hljs">连续分配：
    支持顺序访问和直接访问
    优点是实现简单、存取速度快
    缺点是文件长度不宜动态增加
链接分配：
    隐式链接：每个文件对应一个磁盘块的链表；磁盘块分布在磁盘的任何地方，除最后一个盘块外，每个盘块都有指向下一个盘块的指针。
    显示连接：把用于链接文件各物理块的指针，从每个物理块的块末尾中提取出来，显式的存放在内存的一张链表中，成为文件分配表。
索引分配
</code></pre></div>
<h4 id="4-5-文件共享"><a href="#4-5-文件共享" class="headerlink" title="4.5 文件共享"></a>4.5 文件共享</h4><div class="code-wrapper"><pre><code class="hljs">基于索引节点的共享方式（硬链接）
利用符号链实现文件共享（软链接）（类似于快捷方式）
</code></pre></div>
<h4 id="4-6-文件保护"><a href="#4-6-文件保护" class="headerlink" title="4.6 文件保护"></a>4.6 文件保护</h4><div class="code-wrapper"><pre><code class="hljs">概念：
为了防止文件共享可能会导致文件被破坏或未经批准的用户修改文件，文件系统必须控制用户对文件的存取，为此必须建立保护机制。
方式：
口令保护、加密保护、访问控制
</code></pre></div>
<h4 id="4-7-文件存储空间管理"><a href="#4-7-文件存储空间管理" class="headerlink" title="4.7 文件存储空间管理"></a>4.7 文件存储空间管理</h4><div class="code-wrapper"><pre><code class="hljs">存储空间的划分与初始化：
文件存储设备分成许多大小相同的物理块，并以块为单位交换信息，因此，文件存储设备的管理实质上是对空闲块的组织和管理，它包括空闲块的组织、分配与回收
    空闲表法：
    空闲链表法：
    位示图法：
    成组链接法：
</code></pre></div>
<h4 id="4-8-文件目录和目录文件的区别？目前广泛采用的目录结构形式是哪种？有何优点？"><a href="#4-8-文件目录和目录文件的区别？目前广泛采用的目录结构形式是哪种？有何优点？" class="headerlink" title="4.8 文件目录和目录文件的区别？目前广泛采用的目录结构形式是哪种？有何优点？"></a>4.8 文件目录和目录文件的区别？目前广泛采用的目录结构形式是哪种？有何优点？</h4><div class="code-wrapper"><pre><code class="hljs">文件目录，又称文件控制块，存储的是文件的管理信息，控制对象是单个文件；
目录文件，存储的是若干个文件目录，控制对象是整个文件系统；
目前广泛采用的树形目录结构，优点是：允许文件重命名，实现了文件分类。
</code></pre></div>
<h4 id="4-9-磁盘调度算法"><a href="#4-9-磁盘调度算法" class="headerlink" title="4.9 磁盘调度算法"></a>4.9 磁盘调度算法</h4><div class="code-wrapper"><pre><code class="hljs">4种算法：
先来先服务算法
最短寻找时间优先算法
扫描算法（电梯调度算法）
循环扫描算法
</code></pre></div>
<h2 id="第五章-输入-x2F-输出管理"><a href="#第五章-输入-x2F-输出管理" class="headerlink" title="第五章 输入&#x2F;输出管理"></a>第五章 输入&#x2F;输出管理</h2><h4 id="5-1-I-x2F-O控制方式"><a href="#5-1-I-x2F-O控制方式" class="headerlink" title="5.1 I&#x2F;O控制方式"></a>5.1 I&#x2F;O控制方式</h4><div class="code-wrapper"><pre><code class="hljs">程序直接控制方式:
    工作原理：外设与内存进行数据传输时，每传输一个字，CPU都需要进行循环检查，判断是否已经传输完成。
    传输单位：字
    数据流向：设备与CPU之间、CPU与内存之间
    CPU干预频率：极高
    特点：造成了CPU的极大浪费，使其一直处于“忙等”。
中断驱动方式:
    工作原理：外设要和内存进行数据传输时，允许外设打断CPU运行并请求服务，使得CPU需要在每个指令周期末检查是否有中断，若有中断，则要处理中断，，然后CPU又返回做原来的工作。
    传输单位：字
    数据流向：设备与CPU之间、CPU与内存之间
    CPU干预频率：高
DMA方式:
    工作原理：允许主存和外设在DMA控制器下进行直接交互，在数据传输的整个过程中不需要CPU的参与。
    传输单位：块
    数据流向：设备和内存之间
    CPU干预频率：中等
通道控制方式
    工作原理：是专门负责输入输出的处理机。对DMA方式的改进，可以把对一个数据块的干预减少到对一组数据块的干预。
    传输单位：一组块
    数据流向：设备和内存之间
    CPU干预频率：低
</code></pre></div>
<h4 id="5-2-什么是-DMA-方式？它与中断方式的主要区别是什麽？"><a href="#5-2-什么是-DMA-方式？它与中断方式的主要区别是什麽？" class="headerlink" title="#5.2 什么是 DMA 方式？它与中断方式的主要区别是什麽？"></a>#5.2 什么是 DMA 方式？它与中断方式的主要区别是什麽？</h4><div class="code-wrapper"><pre><code class="hljs">DMA方式是指内存与外设只需要在DMA控制器的控制下进行数据传输，而不需要进行CPU的干预。
与中断方式的主要区别是：
1.中断方式在每个数据需要传输时都需要中断CPU，而DMA方式是在所要求传送的一批数据全部传送完毕时才中断CPU；
2.中断方式中数据传输是在中断处理时由CPU控制完成的，而DMA方式中数据传输是在DMA控制器控制下完成的。
</code></pre></div>
<h4 id="5-3-I-x2F-O子系统的层次结构"><a href="#5-3-I-x2F-O子系统的层次结构" class="headerlink" title="5.3 I&#x2F;O子系统的层次结构"></a>5.3 I&#x2F;O子系统的层次结构</h4><div class="code-wrapper"><pre><code class="hljs">层次组成:
    用户层I/O软件：实现与用户交互的接口，用户可直接调用在用户层提供的、与I/O操作有关的库函数，对设备进行操作。
    设备独立性软件：用于实现用户程序与设备驱动器的统一接口、设备命令、设备保护及设备分配与释放等，同时为设备管理和数据传送提供必要的存储空间。
    设备驱动程序：与硬件直接线管，负责具体实现系统对设备发出的操作指令，驱动I/O设备工作的驱动程序
    中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完并恢复被终端进程的现场后，返回到被中断进程。
    硬件设备
</code></pre></div>
<h4 id="5-4-缓冲区管理"><a href="#5-4-缓冲区管理" class="headerlink" title="*5.4 缓冲区管理"></a>*5.4 缓冲区管理</h4><div class="code-wrapper"><pre><code class="hljs">缓冲技术是一种 以空间换时间的资源换取技术。一般利用内存作为缓冲区。
引入的目的：
1.可以协调CPU与I/O设备之间速度不匹配的矛盾；
2.可以减少对CPU的中断频率；
3.提高设备的利用率。
(总的来说，提高CPU利用率，提高并行度)。
缓冲区类型：
单缓冲、双缓冲、循环缓冲、缓冲池
</code></pre></div>
<h4 id="5-5-设备的分配与回收"><a href="#5-5-设备的分配与回收" class="headerlink" title="5.5 设备的分配与回收"></a>5.5 设备的分配与回收</h4><div class="code-wrapper"><pre><code class="hljs">设备分配是指根据用户的I/O请求分配所需的设备。
合理的分配原则主要考虑的因素：
    I/O设备的固有属性、T/O设备的分配算法、I/O设备分配的安全性以及I/O设备的独立性。
设备分配策略：
    (1)设备分配原则：既要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体设备隔离开。
    (2)设备分配方式：静态分配和动态分配
    (3)设备分配算法：先请求先分配、优先级高者优先
设备分配安全性：
    设备分配中应防止发生进程死锁。
</code></pre></div>
<h4 id="5-6-在设备管理中，何谓设备独立性？如何实现设备独立性？"><a href="#5-6-在设备管理中，何谓设备独立性？如何实现设备独立性？" class="headerlink" title="#5.6 在设备管理中，何谓设备独立性？如何实现设备独立性？"></a>#5.6 在设备管理中，何谓设备独立性？如何实现设备独立性？</h4><div class="code-wrapper"><pre><code class="hljs">设备独立性是指用户程序独立于所使用的具体设备。
实现方式是系统为每个用户进程配置一张用于联系逻辑设备名和物理设备名的映射表，以实现使用逻辑设备名来请求物理设备。
</code></pre></div>
<h4 id="5-7-SPOOLing技术"><a href="#5-7-SPOOLing技术" class="headerlink" title="5.7 SPOOLing技术"></a>5.7 SPOOLing技术</h4><div class="code-wrapper"><pre><code class="hljs">假脱机技术
作用：为了缓和CPU的高速性与I/O设备低速性之间的矛盾，引入了脱机输入/输出技术。
实现设备组成：
    输入井和输出井
    输入缓冲区和输出缓冲区
    输入进程和输出进程
</code></pre></div>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95%E3%80%91/">【计算机考研复试】</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/10/databaseinterview/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【计算机考研复试】数据库系统概论</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/06/MachineLearn/">
                        <span class="hidden-mobile">【机器学习从入门到入土】</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
